#region Initializing any macros that are useful/related to the outline shader handler

// A macro to simplify the look of the code whenever the outline shader struct needs to be referenced.
#macro	SHADER_OUTLINE			global.shaderOutline

#endregion

#region Initializing enumerators that are useful/related to the outline shader handler
#endregion

#region Initializing any globals that are useful/related to the outline shader handler

// Stores the ID values for each font resource's texture for easy and quick reference whenever the outline
// shader is in use. Otherwise, these IDs would need to be retrieved every frame within the code.
global.fontTextures = ds_map_create();
ds_map_add(global.fontTextures, font_gui_small,		font_get_texture(font_gui_small));
ds_map_add(global.fontTextures, font_gui_medium,	font_get_texture(font_gui_medium));
ds_map_add(global.fontTextures, font_gui_large,		font_get_texture(font_gui_large));

#endregion

#region The main object code for the outline shader handler (Used only for Structs)

global.shaderOutline = {
	// Each variable will store the location given to their respective "uniforms" within the shader. These
	// are just integer values that determine the "offset" in memory that the variable is located within the
	// "program" for this shader within the GPU's VRAM it has allocated.
	sPixelWidth :		shader_get_uniform(shd_outline, "pixelWidth"),
	sPixelHeight :		shader_get_uniform(shd_outline, "pixelHeight"),
	sDrawOutline :		shader_get_uniform(shd_outline, "drawOutline"),
	sDrawCorners :		shader_get_uniform(shd_outline, "drawCorners"),
	sColor :			shader_get_uniform(shd_outline, "color"),
	
	// Variables that store redundant data that matches what is currently being used by the respective uniforms
	// within the outline shader program. This will prevent any accesses to those uniforms if the data stored in
	// them matches exactly what is about to be passed into them.
	curTexelWidth :		0,
	curTexelHeight :	0,
	curOutlineColor :	array_create(3, -1),
	
	/// @description Called at the beginning of every frame within "obj_controller". All it does is reset all the
	/// duplicate data variable back to their default values, so the shader can populate them with the in-use data
	/// for the current frame when it is required to do so.
	begin_step : function(){
		curOutlineColor = array_create(3, -1);
		curTexelWidth = 0;
		curTexelHeight = 0;
	},
	
	/// @description Determines the texel width for the in-use font's texture. This is a normalized value between
	/// zero and one relative to the width of the texture page generated by GameMaker that the font is located on.
	/// The value for the width is stored to prevent a duplicate value from being passed into the shader again as
	/// this wastes time processing an unnecessary writing of data to the GPU.
	/// @param fontTexture
	outline_set_texel_width : function(_fontTexture){
		var _texelWidth = texture_get_texel_width(_fontTexture);
		if (_texelWidth != curTexelWidth){
			shader_set_uniform_f(sPixelWidth, texture_get_texel_width(_fontTexture));
			curTexelWidth = _texelWidth;
		}
	},
	
	/// @description This performs the same exact code as the above function, but for the height of the texel given
	/// the texture page's dimensions instead of the width, since that is calculated by the above function. The value
	/// for the texel height is stored in case another font shares the same texture page; preventing a useless setting
	/// of the uniform value to the exact same texel height.
	/// @param fontTexture
	outline_set_texel_height : function(_fontTexture){
		var _texelHeight = texture_get_texel_height(_fontTexture);
		if (_texelHeight != curTexelHeight){
			shader_set_uniform_f(sPixelHeight, texture_get_texel_height(_fontTexture));
			curTexelHeight = _texelHeight;
		}
	}
}

#endregion

#region Global functions related to the outline shader handler

/// @description Initializes the outline shader. If the shader has already been set, the function will do
/// nothing. Otherwise, the shader will be assigned and the required data for the texel dimensions, color,
/// and flags for drawing the outline or corners from the getgo are assigned to each uniform.
/// @param {Asset.GMFont}	font			An existing GML font resource.
/// @param {Array<Real>}	outlineColor	An array with three values for the r, g, and b channels of the outline color.
/// @param {Bool}			drawOutline		Enables/disables the outline outright.
/// @param {Bool}			drawCorners		Enables/disables filling in the corners of the outline.
function shader_set_outline(_font, _outlineColor, _drawOutline = true, _drawCorners = true){
	if (shader_current() == shd_outline) {return;} // Don't bother wasting time if the shader has already been initialized.
	with(SHADER_OUTLINE){
		shader_set(shd_outline);
		
		// First, the correct texel dimensions need to be grabbed for the font. This is important since one
		// font could be stored on one texture page, while another font could be stored on another; the two
		// having different dimensions. These differences will result in unique texel values, so this makes
		// sure that the correct values are calculated for the required font.
		var _fontTexture = global.fontTextures[? _font];
		if (!is_undefined(_fontTexture)){
			outline_set_texel_width(_fontTexture);
			outline_set_texel_height(_fontTexture);
			draw_set_font(_font);
		}
		
		// Overwrite the color of the outline if it differs from what is already being used. Otheriwse, it
		// would be a waste of time to change a uniform to values it already has, and that's a process that
		// should be avoided whenever possible.
		if (!array_equals(_outlineColor, curOutlineColor)){
			shader_set_uniform_f_array(sColor, _outlineColor);
			curOutlineColor = _outlineColor;
		}
		
		// Finally, set the flag values for the shader's parameters that will determine if the corners of the
		// outline are rendered and if the outline itself is enabled to begin with (It can be disabled/enabled)
		// while the shader is active if need be (Ex. drawing outlined text and then a not-outlined sprite in 
		// the same loop iteration, and so on).
		shader_set_uniform_i(sDrawOutline, _drawOutline);
		shader_set_uniform_i(sDrawCorners, _drawCorners);
	}
}

/// @description Assigns a new font for use with the outline shader. If the font provided by the function is
/// the exact same as the previously assigned font this function will execute no code. Otherwise, time would
/// be wasted assigning the same exact font and its texel dimensions to the respective shader uniforms.
/// @param {Asset.GMFont}	font
function outline_set_font(_font){
	with(SHADER_OUTLINE){
		// Don't bother updating any uniforms or the current font if the one passed into this function is the
		// exact same font that is currently being used for rendering text. This saves some processing time for 
		// the shader.
		if (draw_get_font() == _font) {return;}
		draw_set_font(_font);
		
		// Much like the function for initializing the outline shader, the font texture will be grabbed to see
		// if the texel dimensions for it match or differ from the data that is stored in the shader uniforms.
		var _fontTexture = global.fontTextures[? _font];
		if (!is_undefined(_fontTexture)){
			outline_set_texel_width(_fontTexture);
			outline_set_texel_height(_fontTexture);
		}
	}
}

/// @description Overwrites the previously used color (Stored as an array with values ranging from 0 to 1)
/// with a new array of color values. If the color provided is the same as the previous color array, the code
/// will execute nothing since there's no reason to waste time setting up duplicate data.
/// @param {Array<Real>}	color	An array with a size of 3 containing the r, g, and b values for the new color.
function outline_set_color(_color){
	with(SHADER_OUTLINE){
		if (array_equals(_color, curOutlineColor)) {return;} // Don't overwrite the previous color if the new one is the exact same values.
		shader_set_uniform_f_array(sColor, _color);
		curOutlineColor = _color;
	}
}

#endregion