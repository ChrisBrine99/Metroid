#region	Initializing any macros that are useful/related to obj_map_manager

// 
#macro	PLAYER_VISIBLE			0
#macro	MAP_OBTAINED			31

// 
#macro	IS_PLAYER_VISIBLE		(stateFlags & (1 << PLAYER_VISIBLE))
#macro	IS_MAP_OBTAINED			(stateFlags & (1 << MAP_OBTAINED))

// 
#macro	MAP_GRID_WIDTH			160
#macro	MAP_GRID_HEIGHT			90
#macro	MAP_TILE_WIDTH			8
#macro	MAP_TILE_HEIGHT			8

// 
#macro	MAP_MINI_MIN_WIDTH		3
#macro	MAP_MINI_MIN_HEIGHT		3

// 
#macro	MAP_DOOR_NORTH			0
#macro	MAP_DOOR_EAST			1
#macro	MAP_DOOR_SOUTH			2
#macro	MAP_DOOR_WEST			3

// 
#macro	NO_MAP_ICON			   -1
#macro	ICON_SAVE_STATION		0
#macro	ICON_ENERGY_STATION		1
#macro	ICON_AMMO_STATION		2
#macro	ICON_MAP_STATION		3
#macro	ICON_CELL_HAS_ITEM		4
#macro	ICON_ITEM_COLLECTED		5

// 
#macro	PLAYER_FLASH_INTERVAL	20.0

#endregion

#region Initializing enumerators that are useful/related to obj_map_manager
#endregion

#region Initializing any globals that are useful/related to obj_map_manager
#endregion

#region The main object code for obj_map_manager

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_map_manager(_index) : base_struct(_index) constructor{
	// 
	stateFlags = (1 << PLAYER_VISIBLE) | (1 << MAP_OBTAINED);
	
	// 
	mapData		= -1;
	mapColor	= HEX_LIGHT_PINK;
	
	// 
	cells = ds_grid_create(MAP_GRID_WIDTH, MAP_GRID_HEIGHT);
	ds_grid_clear(cells, noone);
	
	// 
	cellWidth	= 0;
	cellHeight	= 0;
	
	// 
	rOriginX	= 12;
	rOriginY	= 12;
	pTrueMapX	= 0.0;
	pTrueMapY	= 0.0;
	pMapX		= 0;
	pMapY		= 0;
	
	// 
	pFlashTimer = 0.0;
	
	/// @description 
	end_step = function(){
		// 
		var _playerX = 0;
		var _playerY = 0;
		with(PLAYER){
			_playerX = x;
			_playerY = y;
		}
		
		// 
		pTrueMapX	= rOriginX + (_playerX / cellWidth);
		pTrueMapY	= rOriginY + (_playerY / cellHeight);
		
		// 
		pMapX = floor(pTrueMapX);
		pMapY = floor(pTrueMapY);
		with(cells[# pMapX, pMapY]) {isExplored = true;}
		
		// 
		pFlashTimer += DELTA_TIME;
		if (pFlashTimer >= PLAYER_FLASH_INTERVAL){
			if (IS_PLAYER_VISIBLE)	{stateFlags &= ~(1 << PLAYER_VISIBLE);}
			else					{stateFlags |=  (1 << PLAYER_VISIBLE);}
			pFlashTimer = 0.0;
		}
	}
	
	/// @description 
	cleanup = function(){
		unload_map_data();
		ds_grid_destroy(cells);
	}
	
	/// @description 
	/// @param {Real}			x			
	/// @param {Real}			y			
	/// @param {Real}			borderIndex
	/// @param {Real}			iconIndex
	/// @param {Array<Struct>}	doorData
	initialize_map_cell = function(_x, _y, _borderIndex, _iconIndex = NO_MAP_ICON, _doorData = []){
		// 
		if (_x < 0 || _x >= MAP_GRID_WIDTH || _y < 0 || _y >= MAP_GRID_HEIGHT 
				|| cells[# _x, _y] != noone) {return;}
				
		// 
		ds_grid_add(cells, _x, _y, {
			border		:	_borderIndex,
			icon		:	_iconIndex,
			doorData	:	array_create(0, noone),
			numDoors	:	0,
			isExplored	:	false
		});
		
		// 
		with(cells[# _x, _y]){
			var _length = array_length(_doorData);
			if (_length > 0){ // 
				numDoors = min(4, _length);
				array_copy(doorData, 0, _doorData, 0, numDoors);
			}
		}
	}
	
	/// @description 
	/// @param {Real}	x		
	/// @param {Real}	y		
	/// @param {Real}	cellX	
	/// @param {Real}	cellY	
	/// @param {Real}	color	
	/// @param {Bool}	hasMap
	draw_map_cell = function(_x, _y, _cellX, _cellY, _color, _hasMap){
		// 
		if (IS_PLAYER_VISIBLE && _cellX == pMapX && _cellY == pMapY){
			draw_sprite_ext(spr_rectangle, 0, _x, _y, MAP_TILE_WIDTH, MAP_TILE_HEIGHT, 0, c_white, 1.0);
			return;
		}
		
		// 
		with(cells[# _cellX, _cellY]){
			// 
			if (!isExplored && !_hasMap){
				draw_sprite_ext(spr_map_borders, 0, _x, _y, 1, 1, 0, c_white, 1.0);
				return;
			}
			
			// 
			if (isExplored)		{draw_sprite_ext(spr_rectangle, 0, _x, _y, MAP_TILE_WIDTH, MAP_TILE_HEIGHT, 0, _color, 1.0);}
			else				{draw_sprite_ext(spr_rectangle, 0, _x, _y, MAP_TILE_WIDTH, MAP_TILE_HEIGHT, 0, HEX_VERY_DARK_BLUE, 1.0);}
			
			// 
			if (border != -1)	{draw_sprite_ext(spr_map_borders, border, _x, _y, 1, 1, 0, c_white, 1.0);}
			if (icon != -1)		{draw_sprite_ext(spr_map_icons, icon, _x + 1, _y + 1, 1, 1, 0, c_white, 1.0);}
			
			// 
			for (var i = 0; i < numDoors; i++){
				with(doorData[i]){
					switch(direction){
						case MAP_DOOR_NORTH:	draw_sprite_ext(spr_rectangle, 0, _x + 3, _y, 2, 1, 0, color, 1.0);		break;
						case MAP_DOOR_SOUTH:	draw_sprite_ext(spr_rectangle, 0, _x + 3, _y + 7, 2, 1, 0, color, 1.0);	break;
						case MAP_DOOR_EAST:		draw_sprite_ext(spr_rectangle, 0, _x + 7, _y + 3, 1, 2, 0, color, 1.0);	break;
						case MAP_DOOR_WEST:		draw_sprite_ext(spr_rectangle, 0, _x, _y + 3, 1, 2, 0, color, 1.0);		break;
					}
				}
			}
			return;
		}
		
		// 
		draw_sprite_ext(spr_map_borders, 0, _x, _y, 1, 1, 0, c_white, 1.0);
	}
	
	/// @description 
	/// @param {String}		file	
	load_map_data = function(_file){
		
	}
	
	/// @description 
	unload_map_data = function(){
		var _length = 0;
		var _cell	= noone;
		for (var xx = 0; xx < MAP_GRID_WIDTH; xx++){
			for (var yy = 0; yy < MAP_GRID_HEIGHT; yy++){
				_cell = cells[# xx, yy]; // Store struct reference into local variable for further manipulation.
				if (_cell == noone) {continue;}
				
				with(_cell){ // Remove door structs from the cell struct before it is freed from memory.
					_length = array_length(doorData);
					for (var i = 0; i < _length; i++) {delete doorData[i];}
				}
				ds_grid_set(cells, xx, yy, noone);
				delete _cell;
			}
		}
	}
}

#endregion

#region Global functions related to obj_map_manager

/// @description Sets the current room's origin, which is used in tandem with Samus's "room cell" position to
/// determine which cell she appears to be occupying on the current world map.
/// @param {Real}	x	Position on the x-axis for the top-left cell of the current room on the map.
/// @param {Real}	y	Position on the y-axis for the top-left cell of the current room on the map.
function map_set_room_origin(_x, _y){
	if (_x < 0 || _x >= MAP_GRID_WIDTH || _y < 0 || _y >= MAP_GRID_HEIGHT) {return;}
	with(MAP_MANAGER){
		rOriginX = _x;
		rOriginY = _y;
	}
}

/// @description 
/// @param {Real}	x			Position along the x axis (In pixels) on the screen to render the map at.
/// @param {Real}	y			Position along the y axis (In pixels) on the screen to render the map at.
/// @param {Real}	cellX		Offset into the map that the viewable area is along the x axis.
/// @param {Real}	cellY		Offset into the map that the viewable area is along the y axis.
/// @param {Real}	width		Total number of columns to be rendered for the visible map area. 
/// @param {Real}	height		Total number of rows to be rendered for the visible map area.
/// @param {Real}	backAlpha	Opacity level for the background of empty map cells.
function map_draw_area(_x, _y, _cellX, _cellY, _width, _height, _backAlpha){
	// 
	if (_cellX < 0 || _cellX + _width >= MAP_GRID_WIDTH || _cellY < 0 || _cellY + _height >= MAP_GRID_HEIGHT) {return;}
	draw_sprite_ext(spr_rectangle, 0, _x, _y, _width * MAP_TILE_WIDTH, _height * MAP_TILE_HEIGHT, 0, HEX_BLACK, _backAlpha);
	
	// 
	with(MAP_MANAGER){
		var _hasMap = IS_MAP_OBTAINED;
		for (var yy = 0; yy < _height; yy++){
			for (var xx = 0; xx < _width; xx++){
				draw_map_cell(_x + (xx * MAP_TILE_WIDTH), _y + (yy + MAP_TILE_HEIGHT), 
					_cellX + xx, _cellY + yy, mapColor, _hasMap);
			}
		}
	}
}

/// @description 
/// @param {Real}	x
/// @param {Real}	y
/// @param {Real}	width
/// @param {Real}	height
/// @param {Real}	backAlpha
function map_draw_area_centered(_x, _y, _width, _height, _backAlpha){
	// 
	if (_width < MAP_MINI_MIN_WIDTH || _height < MAP_MINI_MIN_HEIGHT) {return;}
	draw_sprite_ext(spr_rectangle, 0, _x, _y, _width * MAP_TILE_WIDTH, _height * MAP_TILE_HEIGHT, 0, HEX_BLACK, _backAlpha);
	
	// 
	with(MAP_MANAGER){
		// 
		var _cellX = pMapX - (_width >> 1);
		var _cellY = pMapY - (_height >> 1);
		
		// 
		var _hasMap = IS_MAP_OBTAINED;
		for (var yy = 0; yy < _height; yy++){
			for (var xx = 0; xx < _width; xx++){
				draw_map_cell(_x + (xx * MAP_TILE_WIDTH), _y + (yy * MAP_TILE_HEIGHT), 
					_cellX + xx, _cellY + yy, mapColor, _hasMap);
			}
		}
	}
}

#endregion