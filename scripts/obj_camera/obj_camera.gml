#region	Initializing any macros that are useful/related to obj_camera

// 
#macro	LOCK_CAMERA_X			27
#macro	LOCK_CAMERA_Y			28
#macro	RESET_TARGET_X			29
#macro	RESET_TARGET_Y			30
#macro	VIEW_BOUNDARY			31	// Keeps the camera's view within the confines of the current room.

// 
#macro	IS_CAMERA_X_LOCKED		(stateFlags & (1 << LOCK_CAMERA_X) != 0)
#macro	IS_CAMERA_Y_LOCKED		(stateFlags & (1 << LOCK_CAMERA_Y) != 0)
#macro	CAN_RESET_TARGET_X		(stateFlags & (1 << RESET_TARGET_X) != 0)
#macro	CAN_RESET_TARGET_Y		(stateFlags & (1 << RESET_TARGET_Y) != 0)
#macro	IS_VIEW_BOUND_ENABLED	(stateFlags & (1 << VIEW_BOUNDARY) != 0)

// 
#macro	VIEW_OFFSET_LIMIT_X		20
#macro	VIEW_OFFSET_LIMIT_Y		8

#endregion

#region Initializing enumerators that are useful/related to obj_camera
#endregion

#region Initializing any globals that are useful/related to obj_camera
#endregion

#region	The main object code for obj_camera

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_camera(_index) : base_struct(_index) constructor{
	// 
	x = 0;
	y = 0;
	
	// 
	centerX = 0;
	centerY = 0;
	
	// 
	stateFlags = 0;
	
	// 
	camera = camera_create();
	
	// 
	targetObject = noone;
	targetOffsetX = 0;
	targetOffsetY = 0;
	
	// 
	prevBoundaryID = noone;
	
	// 
	shakeSetStrength = 0.0;
	shakeCurStrength = 0.0;
	shakeDuration = 0.0;
	
	/// @description 
	end_step = function(){
		// 
		follow_target_object(4, 3);
		process_camera_boundaries();
		
		// 
		var _x = floor(x - (camera_get_view_width(camera) * 0.5));
		var _y = floor(y - (camera_get_view_height(camera) * 0.5));
		update_view_position(_x, _y);
		
		// 
		if (shakeCurStrength <= 0.0) {return;}
		shakeCurStrength -= shakeSetStrength / shakeDuration * DELTA_TIME;
		
		// 
		var _shakeStrength = round(shakeCurStrength);
		var _shakeX = camera_get_view_x(camera) + irandom_range(-_shakeStrength, _shakeStrength);
		var _shakeY = camera_get_view_y(camera) + irandom_range(-_shakeStrength, _shakeStrength);
		camera_set_view_pos(camera, _shakeX, _shakeY);
	}
	
	/// @description 
	room_start = function(){
		view_set_camera(0, camera);
		view_set_visible(0, true);
		view_enabled = true;
	}
	
	/// @description 
	cleanup = function(){
		camera_destroy(camera);
	}
	
	/// @description 
	/// @param {Real}	x
	/// @param {Real}	y
	update_view_position = function(_x, _y){
		if (IS_VIEW_BOUND_ENABLED){
			var _width = camera_get_view_width(camera);
			var _height = camera_get_view_height(camera);
			_x = clamp(_x, 0, max(room_width - _width, 0));
			_y = clamp(_y, 0, max(room_height - _height, 0));
		}
		camera_set_view_pos(camera, _x, _y);
	}
	
	/// @description 
	/// @param {Real}	deadzoneWidth
	/// @param {Real}	deadzoneHeight
	follow_target_object = function(_deadzoneWidth, _deadzoneHeight){
		// 
		var _targetX = 0;
		var _targetY = 0;
		with(targetObject){
			_targetX = x;
			_targetY = y;
		}
		_targetX += targetOffsetX;
		_targetY += targetOffsetY;
		
		// 
		if (!IS_CAMERA_X_LOCKED){
			if (_targetX < x - _deadzoneWidth)		{x = _targetX + _deadzoneWidth;}
			else if (_targetX > x + _deadzoneWidth)	{x = _targetX - _deadzoneWidth;}
		}
		
		// 
		if (!IS_CAMERA_Y_LOCKED){
			if (_targetY < y - _deadzoneHeight)			{y = _targetY + _deadzoneHeight;}
			else if (_targetY > y + _deadzoneHeight)	{y = _targetY - _deadzoneHeight;}
		}
	}
	
	/// @description 
	process_camera_boundaries = function(){
		var _targetX = -1;
		var _targetY = -1;
		var _stateFlags = stateFlags;
		var _prevBoundaryID = prevBoundaryID;
		with(targetObject){ // Collision check occurs within the instance that the camera is currently following.
			var _boundary = instance_place(x, y, obj_camera_boundary);
			with(_boundary){
				if (viewTargetX != -1){
					_stateFlags &= ~(1 << RESET_TARGET_X);
					_stateFlags |= (1 << LOCK_CAMERA_X);
					_targetX = viewTargetX;
				}
				
				if (viewTargetY != -1){
					_stateFlags &= ~(1 << RESET_TARGET_Y);
					_stateFlags |= (1 << LOCK_CAMERA_Y);
					_targetY = viewTargetY;
				}
			}
			
			if (_boundary != _prevBoundaryID){
				_prevBoundaryID = _boundary;
				if (_stateFlags & (1 << LOCK_CAMERA_X)) {_stateFlags |= (1 << RESET_TARGET_X);}
				if (_stateFlags & (1 << LOCK_CAMERA_Y)) {_stateFlags |= (1 << RESET_TARGET_Y);}
			}
		}
		prevBoundaryID = _prevBoundaryID;
		stateFlags = _stateFlags;
		
		if (_targetX != -1 && !CAN_RESET_TARGET_X){
			x = value_set_linear(x, _targetX, 4.0);
		} else if (CAN_RESET_TARGET_X){
			x = value_set_linear(x, targetObject.x, 4.0);
			if (x == targetObject.x) {stateFlags &= ~((1 << RESET_TARGET_X) | (1 << LOCK_CAMERA_X));}
		}
		
		if (_targetY != -1 && !CAN_RESET_TARGET_Y){
			y = value_set_linear(y, _targetY, 4.0);
		} else if (CAN_RESET_TARGET_Y){
			y = value_set_linear(y, targetObject.y, 4.0);
			if (y == targetObject.y) {stateFlags &= ~((1 << RESET_TARGET_Y) | (1 << LOCK_CAMERA_Y));}
		}
	}
}

#endregion

#region Global functions related to obj_camera

/// @description 
/// @param {Real}	x			Initial x position of the camera in the room.
/// @param {Real}	y			Initial y position of the camera in the room.
/// @param {Real}	width		Width in pixels for the viewport.
/// @param {Real}	height		Height in pixels for the viewport.
/// @param {Real}	scale		Scale factor for the window relative to the viewport size.
/// @param {Real}	flags		All required flags to apply to the camera upon its initialized.
function camera_initialize(_x, _y, _width, _height, _scale, _flags){
	with(CAMERA){
		// 
		x = _x;
		y = _y;
		stateFlags = _flags;
		
		// 
		camera_set_view_size(camera, _width, _height);
		surface_resize(application_surface, _width, _height);
		display_set_gui_size(_width, _height);
		
		// 
		var _displayWidth = display_get_width();
		var _displayHeight = display_get_height();
		_scale = min(floor(_displayHeight / _height), _scale);
		
		//
		var _windowWidth = _width * _scale;
		var _windowHeight = _height * _scale;
		window_set_size(_windowWidth, _windowHeight);
		window_set_position(floor((_displayWidth - _windowWidth) * 0.5), floor((_displayHeight - _windowHeight) * 0.5));
		
		// 
		update_view_position(_x - (_width * 0.5), _y - (_height * 0.5));
		
		// 
		with(EFFECT_HANDLER){
			windowTexelWidth = 1 / _width;
			windowTexelHeight = 1 / _height;
		}
	}
}

/// @description 
/// @param {Id.Instance}	object
/// @param {Real}			offsetX
/// @param {Real}			offsetY
/// @param {Real}			snapToPosition
function camera_set_target_object(_object, _offsetX, _offsetY, _snapToPosition){
	with(CAMERA){
		targetObject	= _object;
		// Snap the camera's position to the player's instantaneously if the function requires it.
		if (_snapToPosition && instance_exists(_object)){
			x = _object.x;
			y = _object.y;
		}
	}
}

/// @description 
/// @param {Real}	strength	Determines the starting intensity of the effect.
/// @param {Real}	duration	The total length of the shake effect.
function camera_set_shake(_strength, _duration){
	with(CAMERA){
		if (shakeCurStrength < _strength){
			shakeSetStrength	= _strength;
			shakeCurStrength	= _strength;
			shakeDuration		= _duration;
		}
	}
}

#endregion