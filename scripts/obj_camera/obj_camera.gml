#region	Initializing any macros that are useful/related to obj_camera

// The bit flags for the camera, which allow view boundaries to be enabled or disabled along the room's bounds
// OR at given points within the room relative to where the view and player object currently are. The "reset"
// flags transition the view back to the player object before re-enabling standard movement.
#macro	LOCK_CAMERA_X			27
#macro	LOCK_CAMERA_Y			28
#macro	RESET_TARGET_X			29
#macro	RESET_TARGET_Y			30
#macro	VIEW_BOUNDARY			31	// Keeps the camera's view within the confines of the current room.

// Comparison marcos to check the state for a given bit flag that the camera utilizes.
#macro	IS_CAMERA_X_LOCKED		(stateFlags & (1 << LOCK_CAMERA_X) != 0)
#macro	IS_CAMERA_Y_LOCKED		(stateFlags & (1 << LOCK_CAMERA_Y) != 0)
#macro	CAN_RESET_TARGET_X		(stateFlags & (1 << RESET_TARGET_X) != 0)
#macro	CAN_RESET_TARGET_Y		(stateFlags & (1 << RESET_TARGET_Y) != 0)
#macro	IS_VIEW_BOUND_ENABLED	(stateFlags & (1 << VIEW_BOUNDARY) != 0)

// 
#macro	DEADZONE_WIDTH			4
#macro	DEADZONE_HEIGHT			3

#endregion

#region Initializing enumerators that are useful/related to obj_camera
#endregion

#region Initializing any globals that are useful/related to obj_camera
#endregion

#region	The main object code for obj_camera

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_camera(_index) : base_struct(_index) constructor{
	// 
	x = 0;
	y = 0;
	
	// 
	centerX = 0;
	centerY = 0;
	
	// 
	stateFlags = 0;
	
	// 
	camera = camera_create();
	targetObject = noone;
	targetOffsetX = 0;
	targetOffsetY = 0;
	
	// 
	prevBoundaryID = noone;
	
	// 
	shakeSetStrength = 0.0;
	shakeCurStrength = 0.0;
	shakeDuration = 0.0;
	
	/// @description 
	end_step = function(){
		// 
		follow_target_object();
		process_camera_boundaries();
		
		// 
		var _x = floor(x - (camera_get_view_width(camera) * 0.5));
		var _y = floor(y - (camera_get_view_height(camera) * 0.5));
		update_view_position(_x, _y);
		
		// 
		if (shakeCurStrength <= 0.0) {return;}
		shakeCurStrength -= shakeSetStrength / shakeDuration * DELTA_TIME;
		
		// 
		var _shakeStrength = round(shakeCurStrength);
		var _shakeX = camera_get_view_x(camera) + irandom_range(-_shakeStrength, _shakeStrength);
		var _shakeY = camera_get_view_y(camera) + irandom_range(-_shakeStrength, _shakeStrength);
		camera_set_view_pos(camera, _shakeX, _shakeY);
	}
	
	/// @description 
	room_start = function(){
		view_set_camera(0, camera);
		view_set_visible(0, true);
		view_enabled = true;
	}
	
	/// @description 
	cleanup = function(){
		camera_destroy(camera);
	}
	
	/// @description 
	/// @param {Real}	x
	/// @param {Real}	y
	update_view_position = function(_x, _y){
		if (IS_VIEW_BOUND_ENABLED){
			var _width = camera_get_view_width(camera);
			var _height = camera_get_view_height(camera);
			_x = clamp(_x, 0, max(room_width - _width, 0));
			_y = clamp(_y, 0, max(room_height - _height, 0));
		}
		camera_set_view_pos(camera, _x, _y);
	}
	
	/// @description 
	follow_target_object = function(){
		// 
		var _targetX = 0;
		var _targetY = 0;
		with(targetObject){
			_targetX = x;
			_targetY = y;
		}
		_targetX += targetOffsetX;
		_targetY += targetOffsetY;
		
		// 
		if (!IS_CAMERA_X_LOCKED){
			if (_targetX < x - DEADZONE_WIDTH)		{x = _targetX + DEADZONE_WIDTH;}
			else if (_targetX > x + DEADZONE_WIDTH)	{x = _targetX - DEADZONE_WIDTH;}
		}
		
		// 
		if (!IS_CAMERA_Y_LOCKED){
			if (_targetY < y - DEADZONE_HEIGHT)			{y = _targetY + DEADZONE_HEIGHT;}
			else if (_targetY > y + DEADZONE_HEIGHT)	{y = _targetY - DEADZONE_HEIGHT;}
		}
	}
	
	/// @description 
	process_camera_boundaries = function(){
		if (GAME_CURRENT_STATE != GSTATE_NORMAL) {return;}
		
		var _targetX = -1;
		var _targetY = -1;
		var _stateFlags = stateFlags;
		var _prevBoundaryID = prevBoundaryID;
		with(targetObject){ // Collision check occurs within the instance that the camera is currently following.
			var _boundary = instance_place(x, y, obj_camera_boundary);
			with(_boundary){
				// 
				if (viewTargetX != -1){
					_stateFlags &= ~(1 << RESET_TARGET_X);
					_stateFlags |= (1 << LOCK_CAMERA_X);
					_targetX = viewTargetX;
				}
				
				// 
				if (viewTargetY != -1){
					_stateFlags &= ~(1 << RESET_TARGET_Y);
					_stateFlags |= (1 << LOCK_CAMERA_Y);
					_targetY = viewTargetY;
				}
			}
			
			// 
			if (_boundary != _prevBoundaryID){
				_prevBoundaryID = _boundary;
				if (_stateFlags & (1 << LOCK_CAMERA_X)) {_stateFlags |= (1 << RESET_TARGET_X);}
				if (_stateFlags & (1 << LOCK_CAMERA_Y)) {_stateFlags |= (1 << RESET_TARGET_Y);}
			}
		}
		prevBoundaryID = _prevBoundaryID;
		stateFlags = _stateFlags;
		
		// 
		if (_targetX != -1 && !CAN_RESET_TARGET_X){
			x = value_set_relative(x, _targetX, 0.25);
		} else if (CAN_RESET_TARGET_X){
			var _oTargetX = targetObject.x + targetOffsetX;
			x = value_set_relative(x, _oTargetX, 0.25);
			if (abs(x - _oTargetX) <= DEADZONE_WIDTH) {stateFlags &= ~((1 << RESET_TARGET_X) | (1 << LOCK_CAMERA_X));}
		}
		
		// 
		if (_targetY != -1 && !CAN_RESET_TARGET_Y){
			y = value_set_relative(y, _targetY, 0.25);
		} else if (CAN_RESET_TARGET_Y){
			var _oTargetY = targetObject.y + targetOffsetY;
			y = value_set_relative(y, _oTargetY, 0.25);
			if (abs(y - _oTargetY) <= DEADZONE_HEIGHT) {stateFlags &= ~((1 << RESET_TARGET_Y) | (1 << LOCK_CAMERA_Y));}
		}
	}
}

#endregion

#region Global functions related to obj_camera

/// @description 
/// @param {Real}	x			Initial x position of the camera in the room.
/// @param {Real}	y			Initial y position of the camera in the room.
/// @param {Real}	width		Width in pixels for the viewport.
/// @param {Real}	height		Height in pixels for the viewport.
/// @param {Real}	scale		Scale factor for the window relative to the viewport size.
/// @param {Real}	flags		All required flags to apply to the camera upon its initialized.
function camera_initialize(_x, _y, _width, _height, _scale, _flags){
	with(CAMERA){
		// 
		x = _x;
		y = _y;
		stateFlags = _flags;
		
		// 
		camera_set_view_size(camera, _width, _height);
		surface_resize(application_surface, _width, _height);
		display_set_gui_size(_width, _height);
		
		// 
		var _displayWidth = display_get_width();
		var _displayHeight = display_get_height();
		_scale = min(floor(_displayHeight / _height), _scale);
		
		//
		var _windowWidth = _width * _scale;
		var _windowHeight = _height * _scale;
		window_set_size(_windowWidth, _windowHeight);
		window_set_position(floor((_displayWidth - _windowWidth) * 0.5), floor((_displayHeight - _windowHeight) * 0.5));
		
		// 
		update_view_position(_x - (_width * 0.5), _y - (_height * 0.5));
		
		// 
		with(EFFECT_HANDLER){
			windowTexelWidth = 1 / _width;
			windowTexelHeight = 1 / _height;
		}
	}
}

/// @description Sets the camera to follow a specific instance that exists within the room. If no object with
/// the given ID exists within the room, the camera will not attempt to target them.
/// @param {Id.Instance}	object			The unique ID value for the instance that the camera will follow.
/// @param {Real}			offsetX			Positional offset relative to the followed object's X origin value.
/// @param {Real}			offsetY			Positional offset relative to the followed object's Y origin value.
function camera_set_target_object(_object, _offsetX, _offsetY){
	with(CAMERA){
		if (instance_exists(_object)){
			targetObject =		_object;	// Stores ID and offset paramters.
			targetOffsetX =		_offsetX;
			targetOffsetY =		_offsetY;
			x = _object.x + _offsetX;		// Snaps camera to proper position.
			y = _object.y + _offsetY;
		}
	}
}

/// @description Applies a shaking effect to the camera of variable duration and intendity. If the strength
/// for the shaking is higher than what is currently applied to the camera (If any shake at all), the new
/// shake effect's parameters will overwrite the previous. Otherwise, the previous will continue on as normal.
/// @param {Real}	strength	Determines the starting intensity of the effect.
/// @param {Real}	duration	The total length of the shake effect.
function camera_set_shake(_strength, _duration){
	with(CAMERA){
		if (shakeCurStrength < _strength){
			shakeSetStrength	= _strength;
			shakeCurStrength	= _strength;
			shakeDuration		= _duration;
		}
	}
}

#endregion