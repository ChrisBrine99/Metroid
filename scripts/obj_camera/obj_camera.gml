/// @description A file containing all the code and logic for the game's camera. 

#region	Initializing any macros that are useful/related to obj_camera

// Macros that store the function pointers that can be used as states within the camera object; allowing for
// easy reference of these within other objects and such.
#macro	STATE_FOLLOW_OBJECT		CAMERA.state_follow_object

#endregion

#region Initializing enumerators that are useful/related to obj_camera
#endregion

#region Initializing any globals that are useful/related to obj_camera
#endregion

#region	The main object code for obj_camera

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_camera(_index) : base_struct(_index) constructor{
	// Much like Game Maker's own x and y variables, these store the current position of the camera within 
	// the current room. By default they are always set to a value of zero.
	x = 0;
	y = 0;
	
	// An array that stores the current function that the camear uses as its "state" and the arguments that
	// are required for that state to function properly. Mostly used for following an object around the room.
	curState = array_create(1, NO_STATE);
	
	// An inner struct that contains information about the camera's viewport itself, which determines what
	// the player is able to see within the room relative to the position of it and its dimensions. It also
	// stores the ID of the camera that the game uses, so it can be manipulated within code.
	camera = {
		ID			:	camera_create(),
		width		:	0,
		height		:	0,
		lockBounds	:	false,
		
		/// @description Updates the camera's viewport position within the room whenever it's called. When the
		/// view's coordinates are locked to stay within the room's boundaries, this function will automatically
		/// perform that logic as necessary.
		/// @param {Real}	x	Position along the x-axis to place the viewport at.
		/// @param {Real}	y	Position along the y-axis to place the viewport at.
		update_view_position : function(_x, _y){
			if (lockBounds){
				var _clampX = clamp(_x - (width / 2), 0, room_width - width);
				var _clampY = clamp(_y - (height / 2), 0, room_height - height);
				camera_set_view_pos(ID, _clampX, _clampY);
			} else{ // No view-locking; set the viewport to whatever the updated position is.
				camera_set_view_pos(ID, _x - (width / 2), _y - (height / 2));
			}
		},
		
		/// @description Functions that simply return the width and height of the viewport, respectively.
		get_width :	function() {return width;},
		get_height : function() {return height;}
	};
	
	// A struct that stores information about the camera's shacking effect. When applied, the camera's view
	// will be offset randomly within the range of the shake's power relative to its remaining duration.
	shakeData = {
		initialPower :	0,
		curPower :		0,
		duration :		0,
	};
	
	/// @description Code that should be placed into the "Cleanup" event of whatever object is controlling
	/// obj_camera. In short, it will cleanup any data that needs to be freed from memory that isn't collected
	/// by Game Maker's built-in garbage collection handler.
	static cleanup = function(){
		camera_destroy(camera.ID);
		delete camera;
		delete shakeData;
	}
	
	/// @description Code that should be placed into the "End Step" event of whatever object is controlling
	/// obj_camera. In short, it will execute the function found in the "curState" array (If there even is one 
	/// that needs to be executed) and also update the camera's positional offset if it's currently shaking.
	end_step = function(){
		// Execute the state for the current frame if there is one to execute.
		var _state = curState[0];
		if (_state != NO_STATE) {script_execute_ext(_state, curState, 1);}
		
		// Updating the shake effect; lowering its intensity according to its duration until it's no longer
		// being applied to the camera. This is the only time that the view can show areas outside of the room
		// even if the boundary lock is applied.
		var _camera = camera.ID;
		var _x = x;
		var _y = y;
		with(shakeData){
			if (curPower > 0){
				curPower -= initialPower / duration * DELTA_TIME;
				_x += irandom_range(-curPower, curPower);
				_y += irandom_range(-curPower, curPower);
				camera_set_view_pos(_camera, _x, _y);
			}
		}
	}
	
	/// @description Code that should be placed into the "Room Start" event of whatever object is controlling
	/// obj_camera. In short, it simply enables the viewport for the new room and sets said view to be visible 
	/// AND attaches the camera's camera to it by providing its ID.
	room_start = function(){
		view_enabled = true;
		view_set_camera(0, camera.ID);
		view_set_visible(0, true);
	}
	
	/// @description The camera's default movement function, which will follow the given object around the 
	/// current room. There are two dead zone values that will determine how far from the center of the view
	/// the followed object needs to be before the camera moves to keep them within the deadzone region.
	/// @param {Id.Instance}	objectID	The instance that the camera will follow around the room.
	/// @param {Real}			deadzoneX	The horizontal bounds of the camera's deadzone.
	/// @param {Real}			deadzoneY	The vertical bounds of the camera's deadzone.
	state_follow_object = function(_objectID, _deadzoneX, _deadzoneY){
		// Attempt to grab the followed object's current coordinates within the room. If the id is an invalid
		// object, the coordinates (0, 0) will be used as a default for the camera to target in this state.
		var _targetX = 0;
		var _targetY = 0;
		with(_objectID){
			_targetX = x;
			_targetY = y;
		}
		
		// Move the camera to match the target's position if they exceed the bounds of the deadzone hoizontally,
		// vertically, or both at the same time.
		if (_targetX > x + _deadzoneX)		{x = _targetX - _deadzoneX;}
		else if (_targetX < x - _deadzoneX)	{x = _targetX + _deadzoneX;}
		if (_targetY > y + _deadzoneY)		{y = _targetY - _deadzoneY;}
		else if (_targetY < y - _deadzoneY)	{y = _targetY + _deadzoneY;}
		
		// Apply the new position for the camera to its viewport; keeping the followed object in the deadzone.
		// If view locking is active, the view's coordinates will be clamped so that they only show what's in
		// the current room.
		var _x = x;
		var _y = y;
		with(camera) {update_view_position(_x, _y);}
	}
}

#endregion

#region Global functions related to obj_camera

/// @description Initializes the game camera by setting the game's viewport dimensions; the window's size,
/// scaling, and position on the user's display, as well as handling the initialized view's bounary logic if 
/// required. On top of that, anything requiring the viewport's width and height will be updated to match the
/// viewport's width and height set within this function.
/// @param {Real}	x				Initial x position of the camera in the room.
/// @param {Real}	y				Initial y position of the camera in the room.
/// @param {Real}	width			Width in pixels for the viewport.
/// @param {Real}	height			Height in pixels for the viewport.
/// @param {Real}	scale			Scale factor for the window relative to the viewport size.
/// @param {Real}	lockViewBounds	Prevents the camera from showing the outside of a given room.
function camera_initialize(_x, _y, _width, _height, _scale, _lockViewBounds){
	with(CAMERA){
		// Store desired position for the camera within its X and Y variables, which will not be equal to the
		// actual camera's view coordinates depending on the view lock setting.
		x = _x;
		y = _y;
		
		// Jump into the camera data struct to assign the width, height, view locking state, and initial
		// position within the room to place the camera at once all its properties have been initialized.
		with(camera){
			width = _width;
			height = _height;
			lockBounds = _lockViewBounds;
			update_view_position(_x, _y);
			camera_set_view_size(ID, _width, _height);
		}
		
		// Determine the maximum possible vertical scale allowed by the user's primary display; making that the
		// maximum overall scaling for the application window, and using that to scale the window properly.
		var _maxScale = floor(display_get_height() / _height);
		var _windowWidth = min(_width * _scale, _width * _maxScale);
		var _windowHeight = min(_height * _scale, _height * _maxScale);
		window_set_size(_windowWidth, _windowHeight);
		
		// Position the window so it will be in the middle of the user's primary display.
		var _windowX = floor((display_get_width() - _windowWidth) / 2);
		var _windowY = floor((display_get_height() - _windowHeight) / 2);
		window_set_position(_windowX, _windowY);
		
		// Match the dimensions of the application surface and the GUI surface to the camera's dimensions to
		// avoid any difference in pixel sizes between each element in the game's application window.
		surface_resize(application_surface, _width, _height);
		display_set_gui_size(_width, _height);
		
		// Update the texel size used by post processing effects so they will match up with the size of the
		// pixels on the application surface as they are normalized between to values between 0 and 1.
		with(EFFECT_HANDLER){
			windowTexelWidth = 1 / _width;
			windowTexelHeight = 1 / _height;
		}
	}
}

/// @description A simple function that will instantly snap the camera to a new position within the current
/// room. If view bound locking is enabled, the view will be limited to the room's dimensions regardless of
/// the argument values.
/// @param {Real}	x	Position on the x-axis to place the camera at in the room.
/// @param {Real}	y	Position on the y-axis to place the camera at in the room.
function camera_set_position(_x, _y){
	with(CAMERA){
		x = _x;
		y = _y;
		with(camera) {update_view_position(_x, _y);}
	}
}

/// @description Determines what code will be executed every step within the Camera struct, which will mostly
/// be functions that update its position to follow a given object around the current room.
/// @param {Function}	state	The function the camera will call every frame after this function is called.
/// @param {Array<Any>}	args	All the arguments required for the state function to execute without crashing.
function camera_set_state(_state, _args){
	with(CAMERA){
		var _stateScript = method_get_index(_state);
		if (script_exists(_stateScript)) {curState[0] = _stateScript;}
		array_copy(curState, 1, _args, 0, array_length(_args));
	}
}

/// @description A simple function that applies a shake to the camera for a set duration. In order for the
/// supplied argument to overwrite the current shake effect, the strength must be greater in intensity.
/// Otherwise, the function will simply do nothing.
/// @param {Real}	power
/// @param {Real}	duration
function camera_set_shake(_power, _duration){
	with(CAMERA.shakeData){
		if (_power >= curPower){
			initialPower = _power;
			curPower = _power;
			duration = _duration;
		}
	}
}

/// @description Functions that will return the current width and height of the camera, respectively. This
/// usually allows for aspect ratio adjustments to be made, but this game requires a 16:9 aspect ratio in order
/// to have a proper grid-based map system.
function camera_get_width()			{return CAMERA.camera.get_width();}
function camera_get_height()		{return CAMERA.camera.get_height();}

#endregion