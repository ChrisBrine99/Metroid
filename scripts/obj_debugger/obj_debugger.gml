#region Initializing any macros that are useful/related to obj_debugger

// Bit positions for the state flags that determine what information is and isn't shown by the Debugger struct.
#macro	DBG_SHOW_TIME			0x00000001	//  0
#macro	DBG_SHOW_GAME_STATE		0x00000002	//  1
#macro	DBG_SHOW_FPS			0x00000004	//  2
#macro	DBG_SHOW_RENDER			0x00000008	//  3
#macro	DBG_SHOW_ROOM			0x00000010	//  4
#macro	DBG_SHOW_CAMPOS			0x00000020	//  5
#macro	DBG_SHOW_INSTANCES		0x00000040	//  6
#macro	DBG_SHOW_MAP			0x00000080	//  7
#macro	DBG_SHOW_LIGHT_POS		0x20000000	// 29
#macro	DBG_SHOW_COLLIDERS		0x40000000	// 30
#macro	DBG_SHOW_WINDOW			0x80000000	// 31

// Condenses the code required to check any of the Console's bit flags' current states into macro values.
#macro	CAN_SHOW_TIME			(stateFlags & DBG_SHOW_TIME)
#macro	CAN_SHOW_GAME_STATE		(stateFlags & DBG_SHOW_GAME_STATE)
#macro	CAN_SHOW_FPS			(stateFlags & DBG_SHOW_FPS)
#macro	CAN_SHOW_RENDER			(stateFlags & DBG_SHOW_RENDER)
#macro	CAN_SHOW_ROOM			(stateFlags & DBG_SHOW_ROOM)
#macro	CAN_SHOW_CAMPOS			(stateFlags & DBG_SHOW_CAMPOS)
#macro	CAN_SHOW_INSTANCES		(stateFlags & DBG_SHOW_INSTANCES)
#macro	CAN_SHOW_MAP_INFO		(stateFlags & DBG_SHOW_MAP)
#macro	CAN_SHOW_LIGHT_POS		(stateFlags & DBG_SHOW_LIGHT_POS)
#macro	CAN_SHOW_COLLIDERS		(stateFlags & DBG_SHOW_COLLIDERS)
#macro	CAN_SHOW_WINDOW			(stateFlags & DBG_SHOW_WINDOW)

// Stores the width and height in pixels that the Debugger's infromation window surface. This determines the
// region that the text infromation within the surface can show up on the screen at relative to the position
// the surface is drawn at on-screen.
#macro	DBG_WINDOW_WIDTH		130
#macro	DBG_WINDOW_HEIGHT		156

// Stores the height in pixels that a line of text on the debug information window is, as well as the amount
// in pixels that exists between each section so the text isn't too cluttered.
#macro	DBG_LINE_HEIGHT			8
#macro	DBG_SECTION_PADDING		2

#endregion

#region Initializing any globals that are useful/related to obj_debugger
#endregion

#region The main object code for obj_debugger

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_debugger(_index) : base_struct(_index) constructor{
	// 
	stateFlags = 0;
	
	// Variables for the surface that is responsible for showing all the text information that is shown to the
	// user on the Debug window. The first value is the surface's index, and the other variables determine the
	// current in pixels the user has scrolled the text to as well as the limit that it can scroll down to.
	surfInfoWindow	= -1;
	scrollOffset	= 0;
	scrollLimit		= 0;
	
	// Keeps track of the index of the last room the game had loaded.
	lastRoom = room;
	
	// Create the Console struct instance, and store its "ID" within this variable so the Debugger can manage
	// the struct; calling its events when required and removing it from memory during the cleanup event.
	console = instance_create_struct(obj_console);
	
	/// @description The standard cleanup function for the Debugger, which mimics how GameMaker's own "cleanup"
	/// event. As such, it should be called within the "cleanup" event by the controller object that manages
	/// this struct.
	cleanup = function(){
		if (surface_exists(surfInfoWindow)) 
			surface_free(surfInfoWindow);
		
		console.cleanup();
		delete console;
	}
	
	/// @description The "End Step" function for the struct, which should be called in the "End Step" event of 
	/// the obejct that is set to managed this one. It will update the Console struct that is managed by the
	/// Debugger while also processing input logic for itself.
	end_step = function(){
		// First, handle logic for the Console, as it will be updated whether or not the Debugger is opened
		// and actively processing and showing information. If it is active, the debugger's functionality will
		// be temporarily disabled.
		with(console){
			end_step();
			if (IS_CONSOLE_ACTIVE) 
				return;
		}
		
		// Pressing the shortcut key "F1" will toggle the rendering of showing Entity colliders on and off.
		// This shortcut key can be pressed regardless of if the Debugger's information window is on or off.
		if (keyboard_check_pressed(vk_f1)){
			if (!CAN_SHOW_COLLIDERS) {stateFlags |= DBG_SHOW_COLLIDERS;}
			else					 {stateFlags &= ~DBG_SHOW_COLLIDERS;}
		}
		
		// When not showing the debug window, the scroll logic will be skipped, but a check will be processed
		// to see if the debugger shortcut has been pressed, which opens up the debug information window without
		// having to enter the console and type out the "tdi" or "toggle_debud_info" command.
		if (!CAN_SHOW_WINDOW){
			if (keyboard_check_pressed(vk_d)) 
				stateFlags |= DBG_SHOW_WINDOW;
			return;
		}
		
		// Handle the debug information's scrolling offset, which will move the text up and down relative to
		// the mouse scroll wheel's input while also keeping it within the current limits for the value.
		scrollOffset += (mouse_wheel_up() - mouse_wheel_down()) * DBG_LINE_HEIGHT;
		if (scrollOffset < scrollLimit) {scrollOffset = scrollLimit;}
		else if (scrollOffset > 0)		{scrollOffset = 0;}
		
		// Check if the shortcut toggle for the Debugger window has been pressed, and close the information
		// window if it is ever pressed.
		if (keyboard_check_pressed(vk_d)) {stateFlags &= ~DBG_SHOW_WINDOW;}
	}
	
	/// @description Renders Debugger information to the application surface AKA world-space. It renders things
	/// like Entity bounding boxes, light origin coordinates, and anything else that would benefit from being
	/// draw in world-space instead of screen-space.
	draw_end = function(){
		draw_entity_colliders();
		draw_light_origins();
	}
	
	/// @description Renders Debugger information onto the GUI surface. Also handles rendering the Console
	/// should it be active and currently rendering its information to the screen.
	draw_gui = function(){
		// First, attempt to render the Console to the screen. If the console happens to be active, it will
		// draw information onto the GUI layer, and will prevent the Debugger from rendering anything until
		// it is closed.
		with(console){
			draw_gui();
			if (IS_CONSOLE_ACTIVE) 
				return;
		}
		
		// Store camera information within a few local variables, which are used at multiple points during the
		// Debugger's GUI rendering; saving time having to get this information if they weren't stored.
		var _camera			= CAMERA.camera;
		var _cameraWidth	= camera_get_view_width(_camera);
		var _cameraHeight	= camera_get_view_height(_camera);
		
		// Display information about the shortcut keys that can be pressed to toggle Entity bounding box rendering
		// on or off, as well as the toggle for enabling or disabling the Debug information window.
		shader_set_outline(font_gui_small, RGB_GRAY);
		draw_set_halign(fa_right);
		draw_text_outline(_cameraWidth - 5, _cameraHeight - 20, "Press [F1] to show colliders\nPress [Insert] for console", HEX_WHITE, RGB_GRAY, 1);
		draw_set_halign(fa_left);
		shader_reset();
		
		// Don't bother rendering anything else to the GUI surface if the Debugger isn't set to render the
		// debug information window.
		if (!CAN_SHOW_WINDOW) 
			return;
		
		// Initialize the surface is it doesn't currently exist within the GPU's VRAM because of an overwrite
		// that occurred during a focus loss or the surface itself hasn't been initialized yet.
		if (!surface_exists(surfInfoWindow))
			surfInfoWindow = surface_create(DBG_WINDOW_WIDTH, DBG_WINDOW_HEIGHT);
		
		// Draw the background of the information window, which has the main background as a simple rectangle,
		// as well as two 12-pixel-tall header rectangles on the top and bottom of the background.
		draw_sprite_ext(spr_rectangle, 0, 0, 0, DBG_WINDOW_WIDTH, _cameraHeight, 0, HEX_BLACK, 0.6);
		draw_sprite_ext(spr_rectangle, 0, 0, 0, DBG_WINDOW_WIDTH, 12, 0, HEX_BLACK, 0.6);
		draw_sprite_ext(spr_rectangle, 0, 0, _cameraHeight, DBG_WINDOW_WIDTH, -12, 0, HEX_BLACK, 0.6);
		
		// Apply the outline shader for the text, and display a header for the debug information window before
		// any actual info is rendered to the window surface.
		shader_set_outline(font_gui_small, RGB_DARK_RED);
		draw_set_halign(fa_center);
		draw_text_outline(DBG_WINDOW_WIDTH >> 1, 2, "--- Debug Info ---", HEX_RED, RGB_DARK_RED, 1);
		
		// Switch over to rendering onto the information window surface, which will store all the text currently
		// drawn relative to the scrolling offset. The surface is cleared to (0, 0, 0, 0) on every frame.
		surface_set_target(surfInfoWindow);
		draw_clear_alpha(HEX_BLACK, 0.0);
		
		// Display the text information to the debug window, which stores the total height of all that info in
		// pixels so the scroll wheel logic knows how far it can scroll down before being stopped, which is set
		// at the end of this event.
		var _sOffset = scrollOffset + DBG_SECTION_PADDING; // Starting offset relative to the (0, 0) point on the surface.
		var _yy		 = _sOffset;
		_yy			+= draw_time_info(_yy);
		_yy			+= draw_game_state_info(_yy);
		_yy			+= draw_fps_info(_yy);
		_yy			+= draw_render_info(_yy);
		_yy			+= draw_room_info(_yy);
		_yy			+= draw_camera_info(_yy, _camera);
		_yy			+= draw_instance_info(_yy);
		_yy			+= draw_map_info(_yy);
		
		// All the required information hhas been drawn. Return to drawing on the application surface and stop
		// rendering using the general outline shader. After both processes have finished, the debug information
		// window is rendered onto the screen.
		surface_reset_target();
		shader_reset();
		draw_surface(surfInfoWindow, 0, 12);
		draw_set_halign(fa_left);
		
		// Calculate the scroll limit based on how much infomation is currently displayed relative to the size
		// of the information window (It's the camera's height minus the 12 pixels headers along its top and
		// bottom). A value of zero is given if there isn't enough information to take up and entire window's
		// worth of space.
		scrollLimit = -max(0, (_yy + DBG_SECTION_PADDING - _sOffset) - DBG_WINDOW_HEIGHT);
	}
	
	/// @description Draws bounding boxes on top of all currently visible dynamic and static entities should
	/// the flag to display such information be toggled true. Off screen entities or entities without a bounding
	/// box will not have anything drawn for them.
	draw_entity_colliders = function(){
		if (!CAN_SHOW_COLLIDERS) 
			return;
		
		with(par_dynamic_entity){
			if (!ENTT_ON_SCREEN || mask_index == spr_empty_mask) 
				continue;
				
			draw_sprite_ext(spr_rectangle, 0, bbox_left, bbox_top, (bbox_right - bbox_left) + 1, 
				(bbox_bottom - bbox_top) + 1, 0, collisionMaskColor, 0.5);
		}

		with(par_static_entity){
			if (!ENTT_ON_SCREEN || mask_index == spr_empty_mask) 
				continue;
				
			draw_sprite_ext(spr_rectangle, 0, bbox_left, bbox_top, (bbox_right - bbox_left) + 1, 
				(bbox_bottom - bbox_top) + 1, 0, collisionMaskColor, 0.5);
		}
	}
	
	/// @description 
	draw_light_origins = function(){
		if (!CAN_SHOW_LIGHT_POS) 
			return;
		
		var _length = ds_list_size(global.lightSources);
		for (var i = 0; i < _length; i++){
			with(global.lightSources[| i]){
				draw_sprite_ext(spr_rectangle, 0, x, y, 1, 1, 0, HEX_BLACK, 1);
			}
		}
	}
	
	/// @description Displays debuf information to the screen; offset relative to the current "scrollOffset"
	/// position. A section's information isn't rendered if it wouldn't show up within the valid bounds of the
	/// debug information window. The section's height in pixels is returned in order to properly offset all
	/// subsequent sections of information relative to the current scroll offset.
	/// @param {Real}	y			Offset on the window to display the information at relative to the current scroll offset.
	/// @param {String}	names		Stores the title of the debug section, as well names for the values that will be shown.
	/// @param {String}	values		Stores all the numerical/text data that will be shown for the section.
	/// @param {Real}	totalLines	Total number of lines that this section takes up, which is used to determine its height in pixels.
	draw_debug_info = function(_y, _names, _values, _totalLines){
		// Calculate the height through the variable that supplies the section's total number of lines as a
		// hard-coded value for efficiency purposes; skipping the need for a "string_height" function call.
		var _height	= (DBG_LINE_HEIGHT * _totalLines) + DBG_SECTION_PADDING;
		
		// Determine if the current y position plus the calculated height is above 0. If so, some part of this
		// section will be visible to the user and should be drawn to the window's surface.
		if (_y + _height > 0){
			draw_set_halign(fa_right);
			draw_text_outline(DBG_WINDOW_WIDTH - 5, _y + DBG_LINE_HEIGHT, _values, HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
			draw_set_halign(fa_left);
			draw_text_outline(5, _y, _names, HEX_WHITE, RGB_GRAY, 1);
		}
		
		// Return that height value so the next section can be properly offset.
		return _height;
	}
	
	/// @description Displays total program and current play time to the debug information window should the
	/// flag to render this information to the window be toggled true.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_time_info = function(_yOffset){
		if (!CAN_SHOW_TIME) 
			return 0;
		
		// Grab the total time that the program has been active for, as well as the current amount of playtime
		// that the user has accumulated throughout a given save file from the Game Manager struct.
		var _totalTime	= 0;
		var _playtime	= 0;
		with(GAME_MANAGER){
			_totalTime	= totalTime;
			_playtime	= curPlaytime;
		}
		
		// Draw the two timer values to the debug information window, but converted from the value they store
		// (Seconds of time) to a standard time format of HH:MM:SS. Milliseconds are not visible for the timers.
		return draw_debug_info(
			_yOffset,
			"-- Time --\n Application\n Playtime",
			string_number_to_time_format(_totalTime) + "\n" +
			string_number_to_time_format(_playtime), 
			3	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays the current and previous game state values to the debug information window should 
	/// the flag to render that information be toggled true.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_game_state_info = function(_yOffset){
		if (!CAN_SHOW_GAME_STATE) 
			return 0;
		
		return draw_debug_info(
			_yOffset,
			"-- Game State --\n Current\n Previous",
			game_state_get_name(GAME_CURRENT_STATE) + "\n" +
			game_state_get_name(GAME_PREVIOUS_STATE),
			3	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays the current frame rate and delta time to the debug information window should the
	/// appropriate flag be toggled to show said data.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_fps_info = function(_yOffset){
		if (!CAN_SHOW_FPS) 
			return 0;
		
		return draw_debug_info(
			_yOffset,
			"-- Frame Rate --\n FPS\n Delta Time",
			string(fps) + "\n" +
			string(DELTA_TIME),
			3	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays information about how many entities (Both dynamic and state) are being rendered
	/// at the current moment. Doesn't account for other draw functions called during an entity's draw event.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_render_info = function(_yOffset){
		if (!CAN_SHOW_RENDER) 
			return 0;
		
		// Get the total number of dynamic and static entities that are being rendered onto the screen for any
		// given frame of gameplay by checking the state of their "ON_SCREEN" substate flag.
		var _dynamicEntities = 0;
		var _staticEntities	 = 0;
		with(par_dynamic_entity){
			if (ENTT_IS_ON_SCREEN)
				_dynamicEntities++;
		}
		with(par_static_entity){
			if (ENTT_IS_ON_SCREEN)
				_staticEntities++;
		}
		
		// Call the function that handles drawing debug text information to the screen; returning the value
		// that it returns so the main drawing function can offset the next piece of debug text properly.
		return draw_debug_info(
			_yOffset,
			"-- Render --\n Entity (Dynamic)\n Entity (Static)\n Lights",
			string(_dynamicEntities) + "\n" +
			string(_staticEntities) + "\n" +
			string(global.lightsDrawn),
			4	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays information about the currently active room, as well as the name and index of the 
	/// previous room that was loaded. The shown information includes its size, its name, and its index value.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_room_info = function(_yOffset){
		if (!CAN_SHOW_ROOM) 
			return 0;
		
		return draw_debug_info(
			_yOffset,
			"-- Room --\n Size\n Current\n Last",
			"[" + string(room_width) + ", " + string(room_height) + "]\n" +
			room_get_name(room) + " (" + string(room) + ")\n" +
			room_get_name(lastRoom) + " (" + string(lastRoom) + ")",
			4	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays information about the game's camera. Namely, its current top-left position of the
	/// viewport within the room, its actual position (Which is the exact center of the current viewport), and
	/// the current dimensions the camera is using for the viewport.
	/// @param {Real}		yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	/// @param {Id.Camera}	cameraID	ID for the camera that is actively rendering the game's viewport.
	draw_camera_info = function(_yOffset, _cameraID){
		if (!CAN_SHOW_CAMPOS) 
			return 0;
		
		// Grab the position of the camera itself (Not the viewport) by storing those coordinates into two
		// local variables to prevent the code from jumping back and forth to grab these values later on.
		var _cameraX		= 0;
		var _cameraY		= 0;
		var _viewTargetX	= 0;
		var _viewTargetY	= 0;
		var _viewMinX		= 0;
		var _viewMinY		= 0;
		var _viewMaxX		= 0;
		var _viewMaxY		= 0;
		with(CAMERA){
			_cameraX		= x;
			_cameraY		= y;
			_viewTargetX	= viewTargetX;
			_viewTargetY	= viewTargetY;
			_viewMinX		= viewMinX;
			_viewMinY		= viewMinY;
			_viewMaxX		= viewMaxX;
			_viewMaxY		= viewMaxY;
		}
		
		// Call the function that handles drawing debug text information to the screen; returning the value
		// that it returns so the main drawing function can offset the next piece of debug text properly.
		return draw_debug_info(
			_yOffset,
			"-- Camera Position --\n Top-Left\n Center\n Size\n\n-- Camera Bounds --\n Target Pos\n Min Pos\n Max Pos",
			"[" + string(camera_get_view_x(_cameraID)) + ", " + string(camera_get_view_y(_cameraID)) + "]\n" +
			"[" + string(_cameraX) + ", " + string(_cameraY) + "]\n" +
			"[" + string(camera_get_view_width(_cameraID)) + ", " + string(camera_get_view_height(_cameraID)) + "]\n\n\n" +
			"[" + string(_viewTargetX) + ", " + string(_viewTargetY) + "]\n" +
			"[" + string(_viewMinX) + ", " + string(_viewMinY) + "]\n" +
			"[" + string(_viewMaxX) + ", " + string(_viewMaxY) + "]",
			9	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays information about "instances" found in the game. It shows the current number of
	/// singleton structs/objects, static entities, dynamic entities, and structs instances that exist within 
	/// the current room.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_instance_info = function(_yOffset){
		if (!CAN_SHOW_INSTANCES) 
			return 0;
		
		return draw_debug_info(
			_yOffset,
			"-- Objects --\n Instances\n Singletons\n Entities (Dynamic)\n Entities (Static)\n Structs",
			string(instance_count) + "\n" +
			string(ds_map_size(global.sInstances)) + "\n" +
			string(instance_number(par_dynamic_entity)) + "\n" +
			string(instance_number(par_static_entity)) + "\n" +
			string(ds_list_size(global.structs)),
			6	// Sum of "\n" in second argument plus one
		);
	}
	
	/// @description Displays internal information about the game's map system to the debug information window
	/// in order to see if the values are behaving as intended. Does nothing if the debug information window
	/// doesn't have this data's visibility flag toggled to true.
	/// @param {Real}	yOffset		Position relative to the current scroll offset to attempt to draw the information at.
	draw_map_info = function(_yOffset){
		if (!CAN_SHOW_MAP_INFO) 
			return 0;
		
		// Grab the required variables from the map manager singleton; storing them into local variables so
		// the code doesn't need to keep jumping to and from the manager in order to get the values.
		var _rOriginX	= 0.0;
		var _rOriginY	= 0.0;
		var _pTrueMapX	= 0.0;
		var _pTrueMapY	= 0.0;
		var _pMapX		= 0;
		var _pMapY		= 0;
		with(MAP_MANAGER){
			_rOriginX	= rOriginX;
			_rOriginY	= rOriginY;
			_pTrueMapX	= pTrueMapX;
			_pTrueMapY	= pTrueMapY;
			_pMapX		= pMapX;
			_pMapY		= pMapY;
		}
		
		// Call the function that handles drawing debug text information to the screen; returning the value
		// that it returns so the main drawing function can offset the next piece of debug text properly.
		return draw_debug_info(
			_yOffset,
			"-- Map --\n Room Origin\n Player Position\n Current Cell",
			"[" + string(_rOriginX) + ", " + string(_rOriginY) + "]\n" + 
			"[" + string(_pTrueMapX) + ", " + string(_pTrueMapY) + "]\n" +
			"[" + string(_pMapX) + ", " + string(_pMapY) + "]",
			4	// Sum of "\n" in second argument plus one
		);
	}
}

#endregion

#region Global functions related to obj_debugger
#endregion