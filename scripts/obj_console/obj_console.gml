#region Initializing any macros that are useful/related to obj_console

// 
#macro	CMD_EXIT_GAME			"exit_game"
#macro	CMD_GAME_STATE			"game_state"

#macro	CMD_SET_EVENT_FLAG		"set_event_flag"
#macro	CMD_SHOW_EVENT_FLAGS	"show_event_flags"
#macro	CMD_SHOW_ALL_FLAGS		"show_all_event_flags"

#macro	CMD_PLAYER_FILL_AMMO	"player_fill_ammo"
#macro	CMD_PLAYER_FILL_ENERGY	"player_fill_energy"
#macro	CMD_INCREASE_MAX_ENERGY	"player_increase_max_energy"
#macro	CMD_INCREASE_MAX_AEION	"player_increase_max_aeion"

#macro	CMD_TOGGLE_DEBUG_INFO	"toggle_debug_window"
#macro	CMD_DEBUG_SHOW_TIME		"debug_show_playtime"
#macro	CMD_DEBUG_SHOW_GSTATE	"debug_show_game_state"
#macro	CMD_DEBUG_SHOW_FPS		"debug_show_fps"
#macro	CMD_DEBUG_SHOW_RENDER	"debug_show_render_data"
#macro	CMD_DEBUG_SHOW_ROOM		"debug_show_room_data"
#macro	CMD_DEBUG_SHOW_CAMERA	"debug_show_camera_data"
#macro	CMD_DEBUG_SHOW_OBJECTS	"debug_show_instance_data"

// 
#macro	DRAW_CURSOR				28
#macro	FIRST_BACKSPACE			29
#macro	FIRST_CURSOR_MOVE		30
#macro	CONSOLE_ACTIVE			31

// 
#macro	CAN_DRAW_CURSOR			(stateFlags & (1 << DRAW_CURSOR) != 0)
#macro	IS_FIRST_BACKSPACE		(stateFlags & (1 << FIRST_BACKSPACE) != 0)
#macro	IS_FIRST_CURSOR_MOVE	(stateFlags & (1 << FIRST_CURSOR_MOVE) != 0)
#macro	IS_CONSOLE_ACTIVE		(stateFlags & (1 << CONSOLE_ACTIVE) != 0)

// 
#macro	FIRST_BSPACE_INTERVAL	30.0
#macro	BSPACE_INTERVAL			1.75

// 
#macro	FIRST_MOVE_INTERVAL		20.0
#macro	CURSOR_MOVE_INTERVAL	1.25
#macro	CURSOR_FLASH_INTERVAL	15.0

// 
#macro	COMMAND_NAME			0
#macro	COMMAND_FUNCTION		1

// 
#macro	TYPE_REAL				5000
#macro	TYPE_BOOL				5001
#macro	TYPE_STRING				5002

// 
#macro	STRING_REAL				"real"
#macro	STRING_BOOL				"bool"
#macro	STRING_STRING			"string"

// 
#macro	HISTORY_DISPLAY_LIMIT	250

#endregion

#region Initializing any globals that are useful/related to obj_console
#endregion

#region The main object code for obj_console

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_console(_index) : base_struct(_index) constructor{
	// Stores whatever was typed by the used, which is then processed once they hit the enter key. It can be used
	// to get the value of an event flag, set or reset flags, create objects, destroy objects, and much more.
	command = "";
	
	// 
	stateFlags = (1 << FIRST_BACKSPACE) | (1 << FIRST_CURSOR_MOVE);
	
	// 
	history = ds_list_create();
	historySurf = -1;
	historyDisplayOffset = 0;
	
	// 
	suggestions = ds_list_create();
	suggestionData = [];
	
	// 
	cursorPos = 1;
	
	// 
	backspaceTimer = 0.0;
	cursorMoveTimer = 0.0;
	cursorTimer = 0.0;
	
	// 
	validCommands = [];
	totalCommands = 0;
	
	// 
	entityStates = ds_map_create();
	
	// 
	gameCurState = GSTATE_NONE;
	gamePrevState = GSTATE_NONE;
	
	/// @description 
	cleanup = function(){
		ds_map_destroy(entityStates);
		ds_list_destroy(history);
		ds_list_destroy(suggestions);
		
		if (surface_exists(historySurf)) {surface_free(historySurf);}
	}
	
	/// @description 
	end_step = function(){
		// 
		if (!IS_CONSOLE_ACTIVE){
			// 
			if (keyboard_check_pressed(vk_insert)){
				var _curState, _nextState, _lastState;
				var _entityStates = entityStates;
				var _key = ds_map_find_first(entityStates);
				with(par_dynamic_entity){
					if (curState == NO_STATE) {continue;}
					
					// 
					_curState = curState;
					_nextState = nextState;
					_lastState = lastState;
					ds_map_add(_entityStates, id, {
						curState	: _curState,
						nextState	: _nextState,
						lastState	: _lastState,
					});
					
					// 
					stateFlags |= (1 << FREEZE_ANIMATION);
					curState	= NO_STATE;
					nextState	= NO_STATE;
					lastState	= NO_STATE;
				}
				
				// 
				stateFlags	   |= (1 << CONSOLE_ACTIVE);
				gameCurState	= GAME_CURRENT_STATE;
				gamePrevState	= GAME_PREVIOUS_STATE;
				game_set_state(GSTATE_PAUSED, true);
				
				// 
				window_set_cursor(cr_default);
				keyboard_lastchar = "";
			}
			return; // No other functionality is processed when the console is closed.
		}
		
		// 
		if (keyboard_check_pressed(vk_insert)){
			var _stateData, _curState, _nextState, _lastState;
			var _key = ds_map_find_first(entityStates);
			while(!is_undefined(_key)){
				_stateData = entityStates[? _key];
				with(_stateData){
					_curState	= curState;
					_nextState	= nextState;
					_lastState	= lastState;
				}
				
				with(_key){
					stateFlags &= ~(1 << FREEZE_ANIMATION);
					curState	= _curState;
					nextState	= _nextState;
					lastState	= _lastState;
				}
				_key = ds_map_find_next(entityStates, _key);
				delete _stateData;
			}
			ds_map_clear(entityStates);
			ds_list_clear(suggestions);
			
			game_set_state(GAME_PREVIOUS_STATE, true);
			window_set_cursor(cr_none);
			stateFlags &= ~((1 << CONSOLE_ACTIVE) | (1 << DRAW_CURSOR));
			stateFlags |= ((1 << FIRST_BACKSPACE) | (1 << FIRST_CURSOR_MOVE));
			backspaceTimer = 0.0;
			cursorMoveTimer = 0.0;
			cursorTimer = 0.0;
			cursorPos = 1;
			command = "";
			return;
		}
		
		// 
		cursorTimer += DELTA_TIME;
		if (cursorTimer >= CURSOR_FLASH_INTERVAL){
			if (CAN_DRAW_CURSOR) {stateFlags &= ~(1 << DRAW_CURSOR);}
			else				 {stateFlags |= (1 << DRAW_CURSOR);}
			cursorTimer = 0.0;
		}
		
		// 
		var _mouseMiddle = mouse_wheel_down() - mouse_wheel_up();
		if (_mouseMiddle != 0){
			historyDisplayOffset += _mouseMiddle * 5;
			if (historyDisplayOffset < 0) {historyDisplayOffset = 0;}
		}
		
		// 
		if (keyboard_check_pressed(vk_enter)){
			if (command != ""){ // Don't bother processing empty strings
				parse_current_command(command);
				ds_list_clear(suggestions);
			}
			keyboard_lastchar = "";
			cursorPos = 1;
			command = "";
			return;
		}
		
		// 
		if (keyboard_check(vk_backspace) && cursorPos > 1){
			backspaceTimer -= DELTA_TIME;
			if (backspaceTimer <= 0.0){
				cursorPos--;
				command = string_delete(command, cursorPos, 1);
				if (command == "") {ds_list_clear(suggestions);}
				else {find_suggestions(command);}
				if (IS_FIRST_BACKSPACE){ // First backspace; longer duration before next character is deleted. 
					backspaceTimer = FIRST_BSPACE_INTERVAL;
					stateFlags &= ~(1 << FIRST_BACKSPACE);
				} else{ // All subsequent backspaces, which are much faster than the initial one.
					backspaceTimer = BSPACE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // Reset backspace variables to enable the longer first deletion interval again.
			stateFlags |= (1 << FIRST_BACKSPACE);
			backspaceTimer = 0.0;
		}
		
		// 
		var _movement = keyboard_check(vk_right) - keyboard_check(vk_left);
		if (_movement != 0){
			cursorMoveTimer -= DELTA_TIME;
			if (cursorMoveTimer <= 0.0){
				if (_movement == 1 && cursorPos <= string_length(command))	{cursorPos++;} 
				else if (_movement == -1 && cursorPos > 1)					{cursorPos--;}
				
				if (IS_FIRST_CURSOR_MOVE){ // Like the backspace code; the first movement will always have a longer duration until the next movement.
					stateFlags &= ~(1 << FIRST_CURSOR_MOVE);
					cursorMoveTimer = FIRST_MOVE_INTERVAL;
				} else{ // All subsequent cursor movements will move at a quick and regular interval.
					cursorMoveTimer = CURSOR_MOVE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // 
			stateFlags |= (1 << FIRST_CURSOR_MOVE);
			cursorMoveTimer = 0.0;
		}
		
		// Adding the next key that was pressed at the end of the current string of command text. The variable
		// that stored the character that we added (A built-in GML variable) is cleared to prevent potential
		// duplication of a character when a non-character key is pressed.
		if (keyboard_lastkey != vk_nokey && keyboard_lastkey != vk_shift && keyboard_lastchar != ""){
			command = string_insert(keyboard_lastchar, command, cursorPos);
			find_suggestions(command);
			keyboard_lastkey = vk_nokey;
			keyboard_lastchar = "";
			cursorPos++;
		}
	}
	
	/// @description 
	draw_gui = function(){
		if (!IS_CONSOLE_ACTIVE) {return;}
		
		// 
		var _cameraID = CAMERA.camera;
		var _camWidth = camera_get_view_width(_cameraID);
		var _camHeight = camera_get_view_height(_cameraID);
		draw_sprite_ext(spr_rectangle, 0, 0, 0, _camWidth, _camHeight, 0, HEX_BLACK, 0.75);
		draw_sprite_ext(spr_rectangle, 0, 0, 163, _camWidth, 12, 0, HEX_DARK_GRAY, 0.5);
		
		// 
		shader_set_outline(font_gui_small, RGB_GRAY);
		draw_text_outline(3, 165, "> ", HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
		draw_text_outline(10, 165, command, HEX_WHITE, RGB_GRAY, 1);
		shader_reset();
		
		// 
		if (CAN_DRAW_CURSOR){
			var _cursorX = string_width(string_copy(command, 1, cursorPos - 1)) + 1;
			draw_sprite_ext(spr_rectangle, 0, 8 + _cursorX, 164, 1, 8, 0, HEX_LIGHT_YELLOW, 1);
		}
		
		// 
		var _start = ds_list_size(history) - 1;
		if (_start >= 0){
			if (!surface_exists(historySurf)){
				var _camera = CAMERA.camera;
				historySurf = surface_create(camera_get_view_width(_camera), camera_get_view_height(_camera) - 20);
			}
			
			// 
			shader_set_outline(font_gui_small, RGB_DARK_GRAY);
			surface_set_target(historySurf);
			draw_clear_alpha(c_black, 0);
			var _text;
			var _yOffset = -historyDisplayOffset;
			for (var i = _start; i >= 0; i--){
				if (_yOffset >= 180) {break;} // Don't bother drawing anything that is above the currently visible history region.
				_text = history[| i];
				_yOffset += string_height(_text);
				if (_yOffset < 0) {continue;} // Skips over text that would be rendered below the history region.
				draw_text_outline(5, 160 - _yOffset, _text, HEX_GRAY, RGB_DARK_GRAY, 1);
				_yOffset += 2;
			}
			surface_reset_target();
			shader_reset();
			draw_surface(historySurf, 0, 0);
		}
		
		// 
		var _suggestionSize = ds_list_size(suggestions);
		if (_suggestionSize > 0){
			draw_sprite_ext(spr_rectangle, 0, 5, 163, _camWidth - 10, -(_suggestionSize * 11) - 3, 0, HEX_GRAY, 1);
			
			var _yy = 152;
			shader_set_outline(font_gui_small, RGB_DARK_YELLOW);
			for (var i = 0; i < _suggestionSize; i++){
				if (_yy <= 0) {break;} // Exit to prevent drawing suggestions that will be drawn off of the screen's visible region.
				draw_text_outline(10, _yy, suggestions[| i], HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
				_yy -= 11;
			}
			shader_reset();
		}
	}
	
	/// @description Attempts to parse out the command data that was typed in by the user. It will find the
	/// required function and any arguments that the function may require. Any errors within this process will
	/// display a failure message in order to let the user know where they messed up in the typed command.
	/// @param {String}	command		The data that was typed into the console command line by the user.
	parse_current_command = function(_command){
		var _funcString = _command;
		var _firstSpace = string_pos(CHAR_SPACE, _funcString);
		if (_firstSpace > 0) {_funcString = string_copy(_command, 1, _firstSpace - 1);}
		history_add_line("> " +_command); // Display the command that was typed into the console's history.
		
		// Attempt to get a valid function's data out of the first chunk of the string, which is used as the
		// name of the function to retrieve the data of. Any data after a space (If there was one used for the
		// function in question) is ignored for this function. If no valid data is found, exit early and show
		// the user an error message within the console's history window.
		var _index = get_function_from_string(string_lower(_funcString));
		if (_index == -1){
			history_add_line("ERROR -- Function \"" + _funcString + "\" does not exist.");
			return;
		}
		
		// After a valid function is found and its data has been retrieved, a check will be performed to see
		// if the function requires arguments in order to function. If so, those functions are parsed out of
		// the remaining string data after the first space in the command string data. Otherwise, just call
		// the function that the user wanted to execute.
		var _data = validCommands[_index];
		if (array_length(_data) > 2){ // Argument types occupy the 3rd index onward.
			var _argString = string_copy(_command, _firstSpace + 1, string_length(_command));
			var _datatypes = []; // Must be initialized before the argument datatypes are copied over to it.
			array_copy(_datatypes, 0, _data, 2, array_length(_data) - 2);
			
			var _arguments = get_arguments_from_string(_argString, _datatypes);
			if (array_length(_arguments) != array_length(_datatypes)){
				var _errorString = "Argument Error: \n" + string(_datatypes) + "\n" + string(_arguments);
				history_add_line(_errorString);
				return;
			}
			script_execute_ext(method_get_index(_data[COMMAND_FUNCTION]), _arguments);
		} else{ // Simply call the requested function.
			_data[COMMAND_FUNCTION]();
		}
	}
	
	/// @description Takes in the first chunk of the command's string (Whatever was typed before the first
	/// space--if there even was a space to begin with) and returns the array index within the function data
	/// that the function requires in order to properly parse the string and use that data to execute it.
	/// @param {String}	string	The string that will be treated as the function name to search for.
	get_function_from_string = function(_string){
		var _index;
		for (var i = 0; i < totalCommands * 0.5; i++){
			if (validCommands[i][COMMAND_NAME] == _string)		{return i;}
			_index = max(totalCommands - 1 - i, 0); // Prevents negative index values from being accessed.
			if (validCommands[_index][COMMAND_NAME] == _string)	{return _index;}
		}
		return -1;
	}
	
	/// @description Takes in the remainder of the "command" string and attempts to parse out the required
	/// arguments for the function that the user is attempting to call. A failure of this function's execution
	/// will return an array that doesn't equal in length to the number of arguments required by the function.
	/// @param {String}			string		Contains all of the function's required arguments; separated by spaces.
	/// @param {Array<Real>}	datatypes	A copy of the datatypes required by the function, which determines how each argument is parsed.
	get_arguments_from_string = function(_string, _datatypes){
		var _argString, _argStringExt;
		var _length		= array_length(_datatypes);
		var _currentArg	= 0;
		var _arguments	= [];
		var _spacePos	= 1;
		var _index		= 1;
		while(_currentArg < _length){
			// Grab the position of the next space between the arguments OR the last character's index value
			// due to it not having anymore arguments so the copying of the substring works as it should
			// (Using "string_pos_ext" for both scenarios would result in "_spacePos" being set to 0 for 
			// the final argument due to no space character existing past that last argument).
			if (_currentArg >= _length - 1)	{_spacePos = string_length(_string) + 1;}
			else							{_spacePos = string_pos_ext(CHAR_SPACE, _string, _index);}
			
			// Parse the string that is pulled from the arguments depending on the datatype required by the 
			// function that is set to be called after this function.
			_argString = string_copy(_string, _index, _spacePos - _index);
			switch(_datatypes[_currentArg]){
				case TYPE_REAL: // Convert the string argument into a number and place it into the argument array.
					if (_argString == ""){
						history_add_line("ERROR -- Invalid input for type \"real\". Aborting command processing...");
						return _arguments;
					}
					_arguments[array_length(_arguments)] = real(_argString);
					break;
				case TYPE_BOOL: // Replace the "true" or "false" string with their GML constant equivalents.
					_argStringExt = string_lower(_argString);
					if (_argStringExt == "true")		{_arguments[array_length(_arguments)] = true;}
					else if (_argStringExt == "false")	{_arguments[array_length(_arguments)] = false;}
					break;
				case TYPE_STRING: // The argument is already a string; simply place it into the argument array.
					_arguments[array_length(_arguments)] = _argString;
					break;
			}
			_index = _spacePos + 1;
			_currentArg++;
		}
		return _arguments;
	}
	
	/// @description 
	/// @param {String}	string
	history_add_line = function(_string){
		if (ds_list_size(history) >= HISTORY_DISPLAY_LIMIT) {ds_list_delete(history, 0);}
		ds_list_add(history, _string);
	}
	
	/// @description 
	/// @param {String}	string
	find_suggestions = function(_string){
		// Ensures that the proper function along with its argument types won't disappear once the user 
		// starts inputting arguments; as the suggestion will disappear as the argument data doesn't match
		// the string data representing those argument types in the suggestion data.
		if (string_count(" ", _string) > 0) {_string = string_copy(_string, 1, string_pos(" ", _string));}
		
		// Loop through the list of suggestion data that can be displayed to the user; adding everything
		// that contains the current command that has been typed in to the list that is then displayed on
		// screen to show the user functions they may want to use based on said command string.
		ds_list_clear(suggestions);
		var _arraySize = array_length(suggestionData);
		var _length = _arraySize * 0.5;
		for (var i = 0; i < _length; i++){
			if (string_count(_string, suggestionData[i]) > 0)
				ds_list_add(suggestions, suggestionData[i]);
			else if (string_count(_string, suggestionData[_arraySize - i - 1]) > 0)
				ds_list_add(suggestions, suggestionData[_arraySize - i - 1]);
		}
	}
	
	/// @description A very simple command that will execute the game's end; closing the application and 
	/// running all existing objects "cleanup" functions to clear any manually allocated memory in the game.
	cmd_exit_game = function(){
		game_end();
	}
	
	/// @description A simple function that displays the game's current state and its previous state (Whatever 
	/// they were set to prior to the console being opened due to it setting the current state to "paused").
	cmd_game_state = function(){
		var _gameState = "Current State: " + game_state_get_name(gameCurState) + "\nPrevious State: " + game_state_get_name(gamePrevState);
		history_add_line(_gameState);
	}
	
	/// @description 
	cmd_player_fill_ammo = function(){
		with(PLAYER){
			numMissiles		= maxMissiles;
			numPowerBombs	= maxPowerBombs;
		}
		history_add_line("Samus's ammunition reserves have been completely filled.");
	}
	
	/// @description 
	cmd_player_fill_energy = function(){
		with(PLAYER){
			hitpoints			= maxHitpoints;
			reserveHitpoints	= maxReserveHitpoints
			curAeion			= maxAeion;
		}
		history_add_line("Samus's current and reserve energy have been completely filled.\nHer aeion gauge has also been filled.");
	}
	
	/// @description 
	/// @param {Real}	modifier	Amount to increase Samus's maximum energy by if possible.
	cmd_player_increase_max_energy = function(_modifier){
		with(PLAYER) {update_maximum_energy(_modifier);}
		history_add_line("Samus's maximum energy has been increased by " + string(_modifier) + " units.");
	}
	
	/// @description 
	/// @param {Real}	modifier	Amount to increase Samus's maximum aeion amount by if possible.
	cmd_player_increase_max_aeion = function(_modifier){
		with(PLAYER) {update_maximum_aeion(_modifier);}
		history_add_line("Samus's maximum aeion has been increased by " + string(_modifier) + " units.");
	}
	
	/// @description Allows the setting/resetting of a desired flag to either 1 (true) or 0 (false), which will
	/// determine if certain objects (Ex. Collectibles) exist within the world or not, if special doorwars are
	/// locked or not, and so on.
	/// @param {Real}	flagID		The ID of the flag that is being manipulated.
	/// @param {Bool}	flagState	The state to set the flag bit to (1 = true, 0 = false).
	cmd_set_event_flag = function(_flagID, _flagState){
		var _flagInfo = "Flag with ID (" + string(_flagID) + ") was set to " + string(_flagState);
		history_add_line(_flagInfo);
		event_set_flag(_flagID, _flagState);
	}
	
	/// @description 
	/// @param {Real}	startBit	The bit that will be the first bit displayed to the console.
	/// @param {Real}	range		The total number of bits to display relative to the starting bit.	
	cmd_show_event_flags = function(_startBit, _range){
		if (_range <= 0){ // The range provided is an invalid number; no bits can be shown as a result.
			history_add_line("ERROR -- Invalid value for range specified (Must be > 0).");
			return; // Command will not be executed due to error.
		} else if (_startBit < 0 || _startBit >= TOTAL_EVENT_FLAG_BYTES * 8){ // Chosen start bit is outside the range of valid bit indexes.
			history_add_line("ERROR -- Starting bit is outside the valid range of event flags (Valid indexes: 0 to " + string((TOTAL_EVENT_FLAG_BYTES * 8) - 1) + ").");
			return; // Command will not be executed due to error.
		}
		
		var _eventFlags = "";
		for (var i = _startBit; i < _startBit + _range; i++) {
			if (i > _startBit){ // Conditions to format the bits shown by the console for readability.
				var _iValue = i - _startBit;
				if ((_iValue % 8) == 0)		{_eventFlags += " ";}
				if ((_iValue % 32) == 0)	{_eventFlags += "\n";}
			}
			_eventFlags += string(event_get_flag(i));
		}
		history_add_line(_eventFlags);
	}
	
	/// @description A simplified version of the above function that will display ALL event flag bits; both used
	/// and unused. The main difference between this and the "show_event_flags" function is the bits here will
	/// be grouped based on what they represent: items, doorways, other, etc..
	cmd_show_all_event_flags = function(){
		history_add_line("Suit Upgrades (Bits 0 and 1):\n" // Displaying flags that alter Samus's suit.
			+ string(event_get_flag(FLAG_VARIA_SUIT)) 
			+ string(event_get_flag(FLAG_GRAVITY_SUIT))
		);
		
		history_add_line("Jump Upgrades (Bits 2 to 4):\n" // Displaying all upgrades to Samus's jumping capabilities.
			+ string(event_get_flag(FLAG_HIJUMP_BOOTS))
			+ string(event_get_flag(FLAG_SPACE_JUMP))
			+ string(event_get_flag(FLAG_SCREW_ATTACK))
		);
		
		var _eventFlags = ""; // Displaying all upgrade flags for Samus's arm cannon.
		for (var i = FLAG_ICE_BEAM; i < FLAG_ENERGY_SHIELD; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Beam Upgrades (Bits 5 to 9):\n" + _eventFlags);
		
		history_add_line("Aeion Upgrades (Bits 10 to 12):\n" // Displaying acquired aeion abilities that Samus has access to.
			+ string(event_get_flag(FLAG_ENERGY_SHIELD))
			+ string(event_get_flag(FLAG_PHASE_SHIFT))
			+ string(event_get_flag(FLAG_SCAN_PULSE))
		);
		
		_eventFlags = ""; // Displaying all currently active morphball upgrades.
		for (var i = FLAG_MORPHBALL; i < FLAG_MISSILES; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Morphball Upgrades (Bits 13 to 18):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all acquired missile upgrades.
		for (var i = FLAG_MISSILES; i < FLAG_LOCK_ON_MISSILES + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Missile Upgrades (Bits 19 to 23):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all small missile tanks Samus has collected.
		for (var i = SMALL_MISSILE_TANK0; i < LARGE_MISSILE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Small Missile Tanks (Bits 32 to 91):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all large missile tanks Samus has collected.
		for (var i = LARGE_MISSILE_TANK0; i < POWER_BOMB_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Large Missile Tanks (Bits 92 to 103):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all power bombs Samus has collected.
		for (var i = POWER_BOMB_TANK0; i < ENERGY_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Power Bomb Tanks (Bits 104 to 115):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tanks Samus has collected.
		for (var i = ENERGY_TANK0; i < ENERGY_TANK_PIECE0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tanks (Bits 116 to 123):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tank pieces Samus has collected.
		for (var i = ENERGY_TANK_PIECE0; i < RESERVE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tank Pieces (Bits 124 to 137):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all reserve tanks Samus has collected.
		for (var i = RESERVE_TANK0; i < AEION_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Reserve Tanks (Bits 138 to 141):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all aeion tanks Samus has collected.
		for (var i = AEION_TANK0; i < AEION_TANK0 + 4; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Aeion Tanks (Bits 142 to 145):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all "special" door flags.
		for (var i = FLAG_SPECIAL_DOOR0; i < FLAG_SPECIAL_DOOR0 + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Unlocked Doors (Bits 150 to 150):\n" + _eventFlags);
	}
	
	/// @description Turns the debug info window on and off; allowing the user to see information about the
	/// game's performance, camera position, room info, and so on.
	cmd_toggle_debug_info = function(){
		var _windowVisible = false;
		with(DEBUGGER){ // Determine if the state bit to flip to 0 or 1 depending on what its current value is.
			_windowVisible = CAN_SHOW_WINDOW;
			if (_windowVisible) {stateFlags &= ~(1 << DBG_SHOW_WINDOW);}
			else				{stateFlags |= (1 << DBG_SHOW_WINDOW);}
		}
		
		// Let the user know what state the debug info window was put into (Shown or not shown) since this
		// function doesn't take a "True" or "False" argument to determine its functionality.
		if (_windowVisible)	{history_add_line("Debug info will not be displayed on screen.");}
		else				{history_add_line("Debug info will now be displayed (Will not display if console is open).");}			
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_playtime = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_TIME);}
			else				{stateFlags &= ~(1 << DBG_SHOW_TIME);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_game_state = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_GAME_STATE);}
			else				{stateFlags &= ~(1 << DBG_SHOW_GAME_STATE);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_fps = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_FPS);}
			else				{stateFlags &= ~(1 << DBG_SHOW_FPS);}
		}
	}
	
	/// @description Allows the user to toggle whether or not information about entity and light source 
	/// rendering--the number of each rendered for the current frame--is displayed in the debug info window.
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_render_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_RENDER);}
			else				{stateFlags &= ~(1 << DBG_SHOW_RENDER);}
		}
	}
	
	/// @description Allows the user to enable or disable the section on the debug info window that displays 
	/// the name of both the current and previous room, respectively.
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_room_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_RENDER);}
			else				{stateFlags &= ~(1 << DBG_SHOW_RENDER);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_camera_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_CAMPOS);}
			else				{stateFlags &= ~(1 << DBG_SHOW_CAMPOS);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_instance_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_INSTANCES);}
			else				{stateFlags &= ~(1 << DBG_SHOW_INSTANCES);}
		}
	}

	// 
	array_push(suggestionData,
		CMD_EXIT_GAME				+ " []",
		CMD_GAME_STATE				+ " []",
		
		CMD_SET_EVENT_FLAG			+ " [ flagID: " + STRING_REAL + ", flagState: " + STRING_STRING + " ]",
		CMD_SHOW_EVENT_FLAGS		+ " [ start: " + STRING_REAL + ", range: " + STRING_REAL + " ]",
		CMD_SHOW_ALL_FLAGS			+ " []",
		
		CMD_PLAYER_FILL_AMMO		+ " []",
		CMD_PLAYER_FILL_ENERGY		+ " []",
		CMD_INCREASE_MAX_ENERGY		+ " [ modifier: " + STRING_REAL + " ]",
		CMD_INCREASE_MAX_AEION		+ " [ modifier: " + STRING_REAL + " ]",
		
		CMD_TOGGLE_DEBUG_INFO		+ " []",
		CMD_DEBUG_SHOW_TIME			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_GSTATE		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_FPS			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_RENDER		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_ROOM			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_CAMERA		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_OBJECTS		+ " [ showInfo: " + STRING_BOOL + " ]",
	);
	
	// Add all console functions to this array, which is used to parse the string data that represents the
	// function from what was typed into the console in order to execute that function. THe size of the array
	// is stored after all the commands are added through here.
	array_push(validCommands,
		[CMD_EXIT_GAME,				cmd_exit_game],
		[CMD_GAME_STATE,			cmd_game_state],
		
		[CMD_SET_EVENT_FLAG,		cmd_set_event_flag, TYPE_REAL, TYPE_BOOL],
		[CMD_SHOW_EVENT_FLAGS,		cmd_show_event_flags, TYPE_REAL, TYPE_REAL],
		[CMD_SHOW_ALL_FLAGS,		cmd_show_all_event_flags],
		
		[CMD_PLAYER_FILL_AMMO,		cmd_player_fill_ammo],
		[CMD_PLAYER_FILL_ENERGY,	cmd_player_fill_energy],
		[CMD_INCREASE_MAX_ENERGY,	cmd_player_increase_max_energy, TYPE_REAL],
		[CMD_INCREASE_MAX_AEION,	cmd_player_increase_max_aeion, TYPE_REAL],
		
		[CMD_TOGGLE_DEBUG_INFO,		cmd_toggle_debug_info],
		[CMD_DEBUG_SHOW_TIME,		cmd_debug_show_playtime, TYPE_BOOL],
		[CMD_DEBUG_SHOW_GSTATE,		cmd_debug_show_game_state, TYPE_BOOL],
		[CMD_DEBUG_SHOW_FPS,		cmd_debug_show_fps, TYPE_BOOL],
		[CMD_DEBUG_SHOW_RENDER,		cmd_debug_show_render_data, TYPE_BOOL],
		[CMD_DEBUG_SHOW_ROOM,		cmd_debug_show_room_data, TYPE_BOOL],
		[CMD_DEBUG_SHOW_CAMERA,		cmd_debug_show_camera_data, TYPE_BOOL],
		[CMD_DEBUG_SHOW_OBJECTS,	cmd_debug_show_instance_data, TYPE_BOOL],
	);
	totalCommands = array_length(validCommands);
}

#endregion

#region Global functions related to obj_console
#endregion