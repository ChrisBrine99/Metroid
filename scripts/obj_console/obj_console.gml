#region Initializing any macros that are useful/related to obj_console

// Positions for the bits that represent states for various parts of the Console's functionality.
#macro	CSL_DRAW_CURSOR			28
#macro	CSL_FIRST_BACKSPACE		29
#macro	CSL_FIRST_CURSOR_MOVE	30
#macro	CSL_CONSOLE_ACTIVE		31

// Condenses the code required to check any of the Console's bit flags' current states into macro values.
#macro	CAN_DRAW_CURSOR			(stateFlags & (1 << CSL_DRAW_CURSOR))
#macro	IS_FIRST_BACKSPACE		(stateFlags & (1 << CSL_FIRST_BACKSPACE))
#macro	IS_FIRST_CURSOR_MOVE	(stateFlags & (1 << CSL_FIRST_CURSOR_MOVE))
#macro	IS_CONSOLE_ACTIVE		(stateFlags & (1 << CSL_CONSOLE_ACTIVE))

// -- General Commands -- //
#macro	CMD_EXIT_GAME			"exit_game"
#macro	CMD_GAME_STATE			"game_state"
#macro	CMD_TOGGLE_GODMODE		"toggle_godmode"
// -- Event Flag Commands -- //
#macro	CMD_SET_EVENT_FLAG		"set_event_flag"
#macro	CMD_SHOW_EVENT_FLAGS	"show_event_flags"
#macro	CMD_SHOW_ALL_FLAGS		"show_all_event_flags"
// -- Object Commands -- //
#macro	CMD_CREATE_OBJECT		"create_object"
#macro	CMD_DESTROY_OBJECT		"destroy_object"
#macro	CMD_MOVE_OBJECT			"move_object"
// -- Entity Commands -- //
#macro	CMD_SET_ENTITY_FLAG		"set_entity_flag"
// -- Player Data Commands -- //
#macro	CMD_PLAYER_FILL_AMMO	"player_fill_ammo"
#macro	CMD_PLAYER_FILL_ENERGY	"player_fill_energy"
#macro	CMD_INCREASE_MAX_ENERGY	"player_increase_max_energy"
#macro	CMD_INCREASE_MAX_AEION	"player_increase_max_aeion"
// -- Debugger Commands -- //
#macro	CMD_TOGGLE_DEBUG		"toggle_debug_window"
#macro	CMD_DEBUG_SHOW_TIME		"debug_show_playtime"
#macro	CMD_DEBUG_SHOW_GSTATE	"debug_show_game_state"
#macro	CMD_DEBUG_SHOW_FPS		"debug_show_fps"
#macro	CMD_DEBUG_SHOW_RENDER	"debug_show_render_data"
#macro	CMD_DEBUG_SHOW_ROOM		"debug_show_room_data"
#macro	CMD_DEBUG_SHOW_CAMERA	"debug_show_camera_data"
#macro	CMD_DEBUG_SHOW_OBJECTS	"debug_show_instance_data"
#macro	CMD_DEBUG_SHOW_MAP		"debug_show_map_data"

// -- Command Shortcuts -- //
#macro	CMD_EXIT				"exit"
#macro	CMD_TGM					"tgm"
#macro	CMD_TDW					"tdw"

// 
#macro	COMMAND_ARG_STRING		0
#macro	COMMAND_FUNCTION		1
#macro	COMMAND_ARGS			2

// Stores the values used for the first backspace and the subsequent backspaces that occur afterward if the
// key is held for longer than that initial interval (60.0 = 1 second).
#macro	FIRST_BSPACE_INTERVAL	30.0
#macro	BSPACE_INTERVAL			1.75

// Like above, the macros here store the values for the first cursor shift, as well as the subsequent shifts
// should the left or right arrow keys be held down for longer than the first interval's duration. The third
// value dictates how fast the cursor will switch between visible and invisible.
#macro	FIRST_MOVE_INTERVAL		20.0
#macro	CURSOR_MOVE_INTERVAL	1.25
#macro	CURSOR_FLASH_INTERVAL	15.0

// Numerical codes for the three valid datatypes that the Console can utilize in its commands. These values
// are what the Console uses when parsing a command to determine what needs to be done before it can be used
// in the function being called by the user's command.
#macro	TYPE_REAL				5000
#macro	TYPE_BOOL				5001
#macro	TYPE_STRING				5002

// String representation for the three valid datatypes that the Console can utilize in its commands. This is
// what is shown to the user whenever they see an argument parameter in the suggestion data area.
#macro	STRING_REAL				"real"
#macro	STRING_BOOL				"bool"
#macro	STRING_STRING			"string"

// Stores the total limit of previous commands and text drawn to the Console's history window before the oldest
// lines begin to be discarded for new infomration.
#macro	HISTORY_DISPLAY_LIMIT	250

// 
#macro	MOUSE_WINDOW_WIDTH		140
#macro	MOUSE_WINDOW_HEIGHT		42

// 
#macro	CSL_TEXT_HEIGHT			8
#macro	CSL_ENTRY_SPACING		2

#endregion

#region Initializing any globals that are useful/related to obj_console
#endregion

#region The main object code for obj_console

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_console(_index) : base_struct(_index) constructor{
	// 
	stateFlags = (1 << CSL_FIRST_BACKSPACE) | (1 << CSL_FIRST_CURSOR_MOVE) | (1 << CSL_DRAW_CURSOR);
	
	// 
	command				= "";
	commandCursorPos	= 1;
	
	// 
	commandData				= ds_map_create();
	commandKeys				= ds_list_create();
	
	// 
	curSuggestions			= ds_list_create();
	suggestionSurf			= -1;
	suggestionOffset		= 0;
	suggestionScrollLimit	= -150;
	
	// Variables for handling the Console's history window, which shows the 250 previous commands and information
	// that have been typed out by the user and displayed to the Console by the resulting command executions.
	history				= ds_list_create();
	historySurf			= -1;
	historyOffset		= 0;
	historyScrollLimit	= -173;
	
	// 
	mInstanceID		= noone;
	mInstanceName	= "";
	mInstanceIndex	= -1;
	mInstanceX		= 0;
	mInstanceY		= 0;
	
	// Stores the states for all entity objects prior to the console being opened, as well as the current and
	// previous game states from that time period as well (The Console sets the state to "PAUSED" which would
	// discard that other previous state without these storage variables).
	entityStates	= ds_map_create();
	gameCurState	= GSTATE_NONE;
	gamePrevState	= GSTATE_NONE;
	
	// Timers that are used for keeping track of the interval of time between the previous and next backspace,
	// cursor movement, and cursor flash, respectively.
	backspaceTimer	= 0.0;
	cursorMoveTimer = 0.0;
	cursorTimer		= 0.0;
	
	/// @description The standard cleanup function for the Console, which mimics how GameMaker's own "cleanup"
	/// event. As such, it should be called within the "cleanup" event by the controller object that manages
	/// this struct.
	cleanup = function(){
		ds_map_destroy(commandData);
		ds_list_destroy(commandKeys);
		ds_list_destroy(curSuggestions);
		ds_list_destroy(history);
		ds_map_destroy(entityStates);

		if (surface_exists(historySurf))	{surface_free(historySurf);}
		if (surface_exists(suggestionSurf)) {surface_free(suggestionSurf);}
	}
	
	/// @description The "End Step" function for the struct, which should be called in the "End Step" event of 
	/// the obejct that is set to managed this one. It will update the Console struct that is managed by the
	/// Debugger while also processing input logic for itself.
	end_step = function(){
		// 
		if (!IS_CONSOLE_ACTIVE){
			if (keyboard_check_pressed(vk_insert))
				enable_console_window();
			return;
		}
		
		// 
		if (keyboard_check_pressed(vk_insert)){
			disable_console_window();
			return;
		}
		
		// 
		cursorTimer += DELTA_TIME;
		if (cursorTimer >= CURSOR_FLASH_INTERVAL){
			if (CAN_DRAW_CURSOR) {stateFlags &= ~(1 << CSL_DRAW_CURSOR);}
			else				 {stateFlags |=  (1 << CSL_DRAW_CURSOR);}
			cursorTimer = 0.0;
		}
		
		// 
		var _mouseMiddle = mouse_wheel_down() - mouse_wheel_up();
		if (_mouseMiddle != 0){
			var _numSuggestions = ds_list_size(curSuggestions);
			if (_numSuggestions == 0){ // No suggestions visible; allow console history window to scroll.
				historyOffset += _mouseMiddle * CSL_TEXT_HEIGHT;
				var _offsetLimit =  max(0, historyScrollLimit);
				if (historyOffset > _offsetLimit)	{historyOffset = _offsetLimit;}
				if (historyOffset < 0)				{historyOffset = 0;}
			} else{ // Suggestions are currently visible; make mouse wheel scroll that section instead.
				suggestionOffset += _mouseMiddle * CSL_TEXT_HEIGHT;
				var _offsetLimit = max(0, suggestionScrollLimit);
				if (suggestionOffset > _offsetLimit) {suggestionOffset = _offsetLimit;}
				else if (suggestionOffset < 0)		 {suggestionOffset = 0;}
			}
		}
		
		// 
		if (keyboard_check_pressed(vk_enter)){
			if (command != "") {parse_current_command();}
			ds_list_clear(curSuggestions);
			keyboard_lastchar	= "";
			command				= "";
			commandCursorPos	= 1;
			return;
		}
		
		// 
		if (keyboard_check(vk_backspace) && commandCursorPos > 1){
			backspaceTimer -= DELTA_TIME;
			if (backspaceTimer <= 0.0){
				commandCursorPos--;
				command = string_delete(command, commandCursorPos, 1);
				find_suggestions();
				if (IS_FIRST_BACKSPACE){ // First backspace; longer duration before next character is deleted. 
					stateFlags	   &= ~(1 << CSL_FIRST_BACKSPACE);
					backspaceTimer	= FIRST_BSPACE_INTERVAL;
				} else{ // All subsequent backspaces, which are much faster than the initial one.
					backspaceTimer	= BSPACE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // Reset backspace variables to enable the longer first deletion interval again.
			stateFlags	   |= (1 << CSL_FIRST_BACKSPACE);
			backspaceTimer	= 0.0;
		}
		
		// 
		var _movement = keyboard_check(vk_right) - keyboard_check(vk_left);
		if (_movement != 0){
			cursorMoveTimer -= DELTA_TIME;
			if (cursorMoveTimer <= 0.0){
				if (_movement == 1 && commandCursorPos <= string_length(command))	{commandCursorPos++;}
				else if (_movement == -1 && commandCursorPos > 1)					{commandCursorPos--;}
				
				if (IS_FIRST_CURSOR_MOVE){ // Like the backspace code; the first movement will always have a longer duration until the next movement.
					stateFlags	   &= ~(1 << CSL_FIRST_CURSOR_MOVE);
					cursorMoveTimer = FIRST_MOVE_INTERVAL;
				} else{ // All subsequent cursor movements will move at a quick and regular interval.
					cursorMoveTimer = CURSOR_MOVE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // 
			stateFlags	   |= (1 << CSL_FIRST_CURSOR_MOVE);
			cursorMoveTimer = 0.0;
		}
		
		// Adding the next key that was pressed at the end of the current string of command text. The variable
		// that stored the character that we added (A built-in GML variable) is cleared to prevent potential
		// duplication of a character when a non-character key is pressed.
		if (keyboard_lastkey != vk_nokey && keyboard_lastkey != vk_shift && keyboard_lastchar != ""){
			command = string_insert(keyboard_lastchar, command, commandCursorPos);
			keyboard_lastkey	= vk_nokey;
			keyboard_lastchar	= "";
			stateFlags		   |= (1 << CSL_DRAW_CURSOR);
			cursorTimer			= 0.0;
			commandCursorPos++;
			find_suggestions();
		}
		
		// 
		var _id = instance_position(mouse_x, mouse_y, all);
		if (_id == mInstanceID) {return;}
		
		// 
		var _name	= "";
		var _index	= -1;
		var _x		= 0;
		var _y		= 0;
		with(_id){
			_name	= object_get_name(object_index);
			_index	= object_index;
			_x		= x;
			_y		= y;
		}
		
		// Finally, take those copied values and place them into the matching variables contained within the
		// Console itself. Overall, this prevents the code jumping back and forth to copy these values one by
		// one and prevents having to cast each value to a string for every draw_gui call.
		mInstanceID		= string(real(_id));
		mInstanceName	= _name;
		mInstanceIndex	= string(_index);
		mInstanceX		= string(_x);
		mInstanceY		= string(_y);
	}
	
	/// @description 
	draw_gui = function(){
		if (!IS_CONSOLE_ACTIVE) {return;}
		
		// 
		var _cameraID		= CAMERA.camera;
		var _cameraWidth	= camera_get_view_width(_cameraID);
		var _cameraHeight	= camera_get_view_height(_cameraID);
		draw_sprite_ext(spr_rectangle, 0, 0, 0, _cameraWidth, _cameraHeight, 0, HEX_BLACK, 0.75);
		draw_sprite_ext(spr_rectangle, 0, 0, 163, _cameraWidth, 12, 0, HEX_DARK_GRAY, 0.5);
		
		// 
		shader_set_outline(font_gui_small, RGB_GRAY);
		draw_text_outline(3, 165, "> ", HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
		draw_text_outline(10, 165, command, HEX_WHITE, RGB_GRAY, 1);
		shader_reset();
		
		// 
		if (CAN_DRAW_CURSOR){
			var _cursorX = string_width(string_copy(command, 1, commandCursorPos - 1)) + 1;
			draw_sprite_ext(spr_rectangle, 0, 8 + _cursorX, 164, 1, 10, 0, HEX_LIGHT_YELLOW, 1);
		}
		
		// 
		var _start = ds_list_size(history) - 1;
		if (_start >= 0){
			if (!surface_exists(historySurf)){
				historySurf = surface_create(
					camera_get_view_width(_cameraID),
					camera_get_view_height(_cameraID) - 17
				);
			}
			
			// 
			surface_set_target(historySurf);
			draw_clear_alpha(c_black, 0.0);
			
			// 
			shader_set_outline(font_gui_small, RGB_DARK_GRAY);
			var _text	 = "";
			var _yOffset = -historyOffset;
			for (var i = _start; i >= 0; i--){
				if (_yOffset >= 163) // Don't bother drawing anything that is above the currently visible history region.
					break;
				_text		= history[| i];
				_yOffset   += string_height(_text);
				if (_yOffset < 0) // Skips over text that would be rendered below the history region.	
					continue;
				draw_text_outline(5, 160 - _yOffset, _text, HEX_GRAY, RGB_DARK_GRAY, 1);
				_yOffset   += CSL_ENTRY_SPACING;
			}
			
			// 
			shader_reset();
			surface_reset_target();
			draw_surface(historySurf, 0, 0);
		}
		
		// 
		var _numSuggestions = ds_list_size(curSuggestions);
		if (_numSuggestions > 0){
			if (!surface_exists(suggestionSurf)){
				suggestionSurf = surface_create(
					camera_get_view_width(_cameraID) - 16,
					camera_get_view_height(_cameraID) - 28
				);
			}
			
			// 
			var _yLimit	= min(152, suggestionScrollLimit + 152);
			draw_sprite_ext(spr_rectangle, 0, 5, 163, _cameraWidth - 10, -_yLimit, 0, HEX_BLACK, 0.85);
			
			// 
			surface_set_target(suggestionSurf);
			draw_clear_alpha(HEX_BLACK, 0.0);
			
			// 
			shader_set_outline(font_gui_small, RGB_DARK_YELLOW);
			var _text	 = "";
			var _yOffset = -suggestionOffset;
			for (var i = 0; i < _numSuggestions; i++){
				if (_yOffset >= _yLimit) // Exit to prevent drawing suggestions that will be drawn off of the screen's visible region.
					break;
				_yOffset += CSL_TEXT_HEIGHT + CSL_ENTRY_SPACING;
				if (_yOffset < 0) // Skips over text that would be rendered below the suggestion region.	
					continue;
				draw_text_outline(2, 152 - _yOffset, curSuggestions[| i], HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
			}
			
			// 
			shader_reset();
			surface_reset_target();
			draw_surface(suggestionSurf, 8, 11);
		}
		
		// 
		var _mouseScreenX = mouse_x - camera_get_view_x(_cameraID);
		var _mouseScreenY = mouse_y - camera_get_view_y(_cameraID);
		draw_sprite_ext(spr_rectangle, 0, _mouseScreenX, _mouseScreenY, 1, 1, 0, HEX_WHITE, 1);
		if (mInstanceID == noone) {return;}
		
		// 
		var _limitX = min(_mouseScreenX + 1, _cameraWidth - MOUSE_WINDOW_WIDTH - 1);
		var _limitY = min(_mouseScreenY + 1, _cameraHeight - MOUSE_WINDOW_HEIGHT - 1);
		draw_sprite_ext(spr_rectangle, 0, _limitX, _limitY, MOUSE_WINDOW_WIDTH, MOUSE_WINDOW_HEIGHT, 0, HEX_BLACK, 0.75); 
		draw_sprite_ext(spr_rectangle, 0, _limitX, _limitY, MOUSE_WINDOW_WIDTH, 12, 0, HEX_DARK_GRAY, 0.25);
	
		// 
		shader_set_outline(font_gui_small, RGB_DARK_YELLOW);
		draw_text_outline(_limitX + 3, _limitY + 15, "Instance ID\nObject Index\nPosition", HEX_WHITE, RGB_GRAY, 1);
		draw_set_halign(fa_right);
		
		// 
		var _dataX = _limitX + MOUSE_WINDOW_WIDTH - 3;
		draw_text_outline(_dataX, _limitY + 2, mInstanceName, HEX_RED, RGB_DARK_RED, 1);
		draw_text_outline(_dataX, _limitY + 15, 
			mInstanceID + "\n" + mInstanceIndex + "\n[" + mInstanceX + ", " + mInstanceY + "]", 
				HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
		
		draw_set_halign(fa_left);
		shader_reset();
	}
	
	/// @description Opens up the Console's main window, which allows the user to input commands via the 
	/// keyboard to execute functions that assist with the debugging process. On top of that, the mouse cursor 
	/// can be used to check instance information by hovering over a given object.
	enable_console_window = function(){
		var _entityStates	= entityStates; // Copy index of ds_map for quick reference while in Entity scope.
		var _curState		= NO_STATE;
		var _nextState		= NO_STATE;
		var _lastState		= NO_STATE;
		with(par_dynamic_entity){
			_curState		= curState;
			_nextState		= nextState;
			_lastState		= lastState;
			
			// 
			ds_map_add(_entityStates, id, {
				curState	: _curState,
				nextState	: _nextState,
				lastState	: _lastState
			});
			
			// 
			stateFlags |= ENTT_PAUSE_ANIM;
			curState	= NO_STATE;
			nextState	= NO_STATE;
			lastState	= NO_STATE;
		}
		
		// 
		stateFlags		   |= (1 << CSL_CONSOLE_ACTIVE) | (1 << CSL_FIRST_BACKSPACE) | 
							  (1 << CSL_FIRST_CURSOR_MOVE) | (1 << CSL_DRAW_CURSOR);
		gameCurState		= GAME_CURRENT_STATE;
		gamePrevState		= GAME_PREVIOUS_STATE;
		command				= "";	// Remove anything that was previous typed as a command.
		commandCursorPos	= 1;
		backspaceTimer		= 0.0;	// Clear all timer variable values.
		cursorMoveTimer		= 0.0;
		cursorTimer			= 0.0;
		
		// Finally, clear out the built-in variable "keyboard_lastchar" to ensure no odd inputs appear in the
		// Console upon start up, and set the game state to PAUSED to signal to various systems to act upon
		// the change relative to their functionalities.
		keyboard_lastchar	= "";
		game_set_state(GSTATE_PAUSED);
	}
	
	/// @description Closes the console window, which resets all Entities back to their previous states,
	/// returns the game state to what it was previously, and also cleans up data structures within the Console
	/// struct that have data that is no longer needed.
	disable_console_window = function(){
		var _key			= ds_map_find_first(entityStates);
		var _stateStruct	= noone;
		var _curState		= NO_STATE;
		var _nextState		= NO_STATE;
		var _lastState		= NO_STATE;
		while(!is_undefined(_key)){
			// First, retrieve the current entity's states from the struct within the entity state storage
			// map; storing each state in a local variable for quick access when in the entity's scope.
			_stateStruct	= entityStates[? _key];
			with(_stateStruct){
				_curState	= curState;
				_nextState	= nextState;
				_lastState	= lastState;
			}
			
			// Jump into the instance ID's scope that these state variables belong to. The flag bit for pausing 
			// the entity's animation (If one was even playing) is cleared to enable animation yet again.
			with(_key){
				stateFlags &= ~ENTT_PAUSE_ANIM;
				curState	= _curState;
				nextState	= _nextState;
				lastState	= _lastState;
			}
			_key = ds_map_find_next(entityStates, _key);
			delete _stateStruct; // Signal to GameMaker that the struct can be cleared from memory.
		}
		
		// Finally, clear the bit that lets the game know the Console is up and active, return the game to 
		// whatever state it was in prior, and clear out the entity state storage map and suggestion list.
		stateFlags &= ~(1 << CSL_CONSOLE_ACTIVE);
		game_set_state(gameCurState, true);
		ds_map_clear(entityStates);
		ds_list_clear(curSuggestions);
	}
	
	/// @description Attempts to parse out the command data that was typed in by the user. It will find the
	/// required function and any arguments that the function may require. Any errors within this process will
	/// display a failure message in order to let the user know where they messed up in the command.
	parse_current_command = function(){
		// 
		var _command	 = command;
		var _firstSpace	 = string_pos(" ", _command);
		if (_firstSpace != 0) {_command = string_copy(command, 1, _firstSpace - 1);}
		var _commandData = ds_map_find_value(commandData, _command);
		
		// 
		if (is_undefined(_commandData)){
			history_add_line("ERROR -- Command \"" + command + "\" doesn't exist.");
			return;
		}
		history_add_line(" > " + command);
		
		// 
		var _commandSize = array_length(_commandData);
		if (_commandSize > COMMAND_ARGS){ // Argument parameters exist from index 2 onward in the command data array.
			// 
			var _datatypes = [];
			array_copy(_datatypes, 0, _commandData, COMMAND_ARGS, array_length(_commandData) - COMMAND_ARGS);
			
			// 
			var _argString = string_copy(command, _firstSpace + 1, string_length(command));
			var _arguments = get_arguments_from_string(_argString, _datatypes);
			if (array_length(_arguments) != array_length(_datatypes)){
				history_add_line("Argument Error: \n" + string(_datatypes) + "\n" + string(_argString));
				return;
			}
			script_execute_ext(method_get_index(_commandData[COMMAND_FUNCTION]), _arguments);
			return;
		}
		
		// 
		_commandData[COMMAND_FUNCTION]();
	}
	
	/// @description Takes in the remainder of the "command" string and attempts to parse out the required
	/// arguments for the function that the user is attempting to call. A failure of this function's execution
	/// will return an array that doesn't equal in length to the number of arguments required by the function.
	/// @param {String}			string		Contains all of the function's required arguments; separated by spaces.
	/// @param {Array<Real>}	datatypes	A copy of the datatypes required by the function, which determines how each argument is parsed.
	get_arguments_from_string = function(_string, _datatypes){
		var _argString		= "";
		var _argStringExt	= "";
		var _length			= array_length(_datatypes);
		var _currentArg		= 0;
		var _arguments		= [];
		var _spacePos		= 1;
		var _index			= 1;
		while(_currentArg < _length){
			// Grab the position of the next space between the arguments OR the last character's index value
			// due to it not having anymore arguments so the copying of the substring works as it should
			// (Using "string_pos_ext" for both scenarios would result in "_spacePos" being set to 0 for 
			// the final argument due to no space character existing past that last argument).
			if (_currentArg >= _length - 1)	{_spacePos = string_length(_string) + 1;}
			else							{_spacePos = string_pos_ext(CHAR_SPACE, _string, _index);}
			
			// Parse the string that is pulled from the arguments depending on the datatype required by the 
			// function that is set to be called after this function.
			_argString = string_copy(_string, _index, _spacePos - _index);
			switch(_datatypes[_currentArg]){
				case TYPE_REAL: // Convert the string argument into a number and place it into the argument array.
					if (_argString == ""){
						history_add_line("ERROR -- Invalid input for type \"real\". Aborting command processing...");
						return _arguments;
					}
					_arguments[_currentArg] = real(_argString);
					break;
				case TYPE_BOOL: // Replace the "true" or "false" string with their GML constant equivalents.
					_argStringExt = string_lower(_argString);
					if (_argStringExt == "true")		{_arguments[_currentArg] = true;}
					else if (_argStringExt == "false")	{_arguments[_currentArg] = false;}
					break;
				case TYPE_STRING: // The argument is already a string; simply place it into the argument array.
					_arguments[_currentArg] = _argString;
					break;
			}
			_index = _spacePos + 1;
			_currentArg++;
		}
		return _arguments;
	}
	
	/// @description Appends a line onto the ds_list that represents the Console's command/information history.
	/// Should the total number of values exceed the history's display limit, the oldest piece of information
	/// will be discarded to make room for the newest value.
	/// @param {String}	string	The line of text that will be added into the Console's history.
	history_add_line = function(_string){
		if (ds_list_size(history) >= HISTORY_DISPLAY_LIMIT){
			historyScrollLimit -= (string_height(history[| 0]) + CSL_ENTRY_SPACING);
			ds_list_delete(history, 0);
		}
		historyScrollLimit += string_height(_string) + CSL_ENTRY_SPACING;
		ds_list_add(history, _string);
	}
	
	/// @description 
	find_suggestions = function(){
		// 
		suggestionOffset		= 0;
		suggestionScrollLimit	= -150;
		ds_list_clear(curSuggestions);
		if (command == "") {return;}
		
		// 
		var _firstSpace = string_pos(" ", command);
		if (_firstSpace > 0){
			var _command	= string_copy(command, 1, _firstSpace - 1);
			var _index		= ds_list_find_index(commandKeys, _command);
			if (_index != -1){
				ds_list_add(curSuggestions, 
					_command + " [ " + commandData[? _command][COMMAND_ARG_STRING] + "]");
			}
			return;
		}
		
		// 
		var _suggestion	= "";
		var _length		= ds_list_size(commandKeys);
		for (var i = 0; i < _length; i++){
			_suggestion = commandKeys[| i];
			if (string_count(command, _suggestion) > 0){
				ds_list_add(curSuggestions, 
					_suggestion + " [ " + commandData[? _suggestion][COMMAND_ARG_STRING] + "]");
				suggestionScrollLimit += (CSL_TEXT_HEIGHT + CSL_ENTRY_SPACING);
			}
		}
	}
	
	/// GENERAL COMMAND FUNCTIONS /////////////////////////////////////////////////////////////////////////////////////
	
	/// @description A very simple command that will execute the game's end; closing the application and 
	/// running all existing objects "cleanup" functions to clear any manually allocated memory in the game.
	cmd_exit_game = function(){
		game_end();
	}
	
	/// @description A simple function that displays the game's current state and its previous state (Whatever 
	/// they were set to prior to the console being opened due to it setting the current state to "paused").
	cmd_game_state = function(){
		history_add_line(
			"Current State: "	+ game_state_get_name(gameCurState) + "\n" + 
			"Previous State: "	+ game_state_get_name(gamePrevState)
		);
	}
	
	/// @description 
	cmd_toggle_godmode = function(){
		
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/// EVENT FLAG COMMAND FUNCTIONS //////////////////////////////////////////////////////////////////////////////////
	
	/// @description Allows the setting/resetting of a desired flag to either 1 (true) or 0 (false), which will
	/// determine if certain objects (Ex. Collectibles) exist within the world or not, if special doorwars are
	/// locked or not, and so on.
	/// @param {Real}	flagID		The ID of the flag that is being manipulated.
	/// @param {Bool}	flagState	The state to set the flag bit to (1 = true, 0 = false).
	cmd_set_event_flag = function(_flagID, _flagState){
		var _flagInfo = "Flag with ID (" + string(_flagID) + ") was set to " + string(_flagState);
		history_add_line(_flagInfo);
		event_set_flag(_flagID, _flagState);
	}
	
	/// @description Displays a given range of bits found within the "global.eventFlags" buffer. It will space
	/// each bit into 8 bit groups; creating a new line once 32 bits have been displayed on a single line.
	/// @param {Real}	startBit	The bit that will be the first bit displayed to the console.
	/// @param {Real}	range		The total number of bits to display relative to the starting bit.	
	cmd_show_event_flags = function(_startBit, _range){
		if (_range <= 0){ // The range provided is an invalid number; no bits can be shown as a result.
			history_add_line("ERROR -- Invalid value for range specified (Must be > 0).");
			return; // Command will not be executed due to error.
		} else if (_startBit < 0 || _startBit >= TOTAL_EVENT_FLAG_BYTES * 8){ // Chosen start bit is outside the range of valid bit indexes.
			history_add_line("ERROR -- Starting bit is outside the valid range of event flags (Valid indexes: 0 to " + string((TOTAL_EVENT_FLAG_BYTES * 8) - 1) + ").");
			return; // Command will not be executed due to error.
		}
		
		var _eventFlags = "";
		for (var i = _startBit; i < _startBit + _range; i++){
			if (i > _startBit){ // Conditions to format the bits shown by the console for readability.
				var _iValue = i - _startBit;
				if ((_iValue % 8) == 0)		{_eventFlags += " ";}
				if ((_iValue % 32) == 0)	{_eventFlags += "\n";}
			}
			_eventFlags += string(event_get_flag(i));
		}
		history_add_line(_eventFlags);
	}
	
	/// @description A simplified version of the above function that will display ALL event flag bits; both used
	/// and unused. The main difference between this and the "show_event_flags" function is the bits here will
	/// be grouped based on what they represent: items, doorways, other, etc..
	cmd_show_all_event_flags = function(){
		history_add_line("Suit Upgrades (Bits 0 and 1):\n" // Displaying flags that alter Samus's suit.
			+ string(event_get_flag(FLAG_VARIA_SUIT)) 
			+ string(event_get_flag(FLAG_GRAVITY_SUIT))
		);
		
		history_add_line("Jump Upgrades (Bits 2 to 4):\n" // Displaying all upgrades to Samus's jumping capabilities.
			+ string(event_get_flag(FLAG_HIJUMP_BOOTS))
			+ string(event_get_flag(FLAG_SPACE_JUMP))
			+ string(event_get_flag(FLAG_SCREW_ATTACK))
		);
		
		var _eventFlags = ""; // Displaying all upgrade flags for Samus's arm cannon.
		for (var i = FLAG_ICE_BEAM; i < FLAG_ENERGY_SHIELD; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Beam Upgrades (Bits 5 to 9):\n" + _eventFlags);
		
		history_add_line("Aeion Upgrades (Bits 10 to 12):\n" // Displaying acquired aeion abilities that Samus has access to.
			+ string(event_get_flag(FLAG_ENERGY_SHIELD))
			+ string(event_get_flag(FLAG_PHASE_SHIFT))
			+ string(event_get_flag(FLAG_SCAN_PULSE))
		);
		
		_eventFlags = ""; // Displaying all currently active morphball upgrades.
		for (var i = FLAG_MORPHBALL; i < FLAG_MISSILES; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Morphball Upgrades (Bits 13 to 18):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all acquired missile upgrades.
		for (var i = FLAG_MISSILES; i < FLAG_LOCK_ON_MISSILES + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Missile Upgrades (Bits 19 to 23):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all small missile tanks Samus has collected.
		for (var i = SMALL_MISSILE_TANK0; i < LARGE_MISSILE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Small Missile Tanks (Bits 32 to 91):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all large missile tanks Samus has collected.
		for (var i = LARGE_MISSILE_TANK0; i < POWER_BOMB_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Large Missile Tanks (Bits 92 to 103):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all power bombs Samus has collected.
		for (var i = POWER_BOMB_TANK0; i < ENERGY_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Power Bomb Tanks (Bits 104 to 115):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tanks Samus has collected.
		for (var i = ENERGY_TANK0; i < ENERGY_TANK_PIECE0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tanks (Bits 116 to 123):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tank pieces Samus has collected.
		for (var i = ENERGY_TANK_PIECE0; i < RESERVE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tank Pieces (Bits 124 to 137):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all reserve tanks Samus has collected.
		for (var i = RESERVE_TANK0; i < AEION_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Reserve Tanks (Bits 138 to 141):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all aeion tanks Samus has collected.
		for (var i = AEION_TANK0; i < AEION_TANK0 + 4; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Aeion Tanks (Bits 142 to 145):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all "special" door flags.
		for (var i = FLAG_SPECIAL_DOOR0; i < FLAG_SPECIAL_DOOR0 + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Unlocked Doors (Bits 150 to 150):\n" + _eventFlags);
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/// ENTITY COMMAND FUNCTIONS //////////////////////////////////////////////////////////////////////////////////////
	
	/// @description 
	/// @param {Real}	instanceID
	/// @param {Real}	flagID
	/// @param {Bool}	flagState
	cmd_set_entity_flag = function(_instanceID, _flagID, _flagState){
		
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/// OBJECT COMMAND FUNCTIONS //////////////////////////////////////////////////////////////////////////////////////
	
	/// @description 
	/// @param {Real}	x
	/// @param {Real}	y
	/// @param {String}	objectName
	cmd_create_object = function(_x, _y, _objectName){
		// 
		if (asset_get_type(_objectName) != asset_object){
			history_add_line("ERROR -- Asset with provided name isn't of type object.");
			return;
		}
		
		// 
		var _index	= asset_get_index(_objectName);
		if (_index == -1){
			history_add_line("ERROR -- Asset with the name \"" + _objectName + "\" doesn't exist!");
			return;
		}
		
		// 
		var _instance = real(instance_create_object(_x, _y, _index));
		history_add_line("Instance of \"" + _objectName + "\" (ID: " + string(_instance) + ") has been created.");
	}
	
	/// @description 
	/// @param {Real}	instanceID		Unique value pointing to the object we want to destroyed.
	/// @param {Bool}	performEvents	Toggles the call to the object's "Destroy" event on/off.
	cmd_destroy_object = function(_instanceID, _performEvents){
		if (!instance_exists(_instanceID)){
			history_add_line("ERROR -- Instance with ID value \"" + string(_instanceID) + "\" doesn't exist.");
			return;
		}
		
		// 
		var _oName = -1;
		with(_instanceID){
			_oName = object_get_name(object_index);
			instance_destroy_object(id, _performEvents);
		}
		
		// 
		if (_performEvents) {history_add_line("Instance of \"" + _oName + "\" with ID " + string(_instanceID) + " has been destroyed.\nIts destroy event was processed.");}
		else {history_add_line("Instance of \"" + _oName + "\" with ID " + string(_instanceID) + " has been destroyed.\nIts destroy event was skipped.");}
	}
	
	/// @description 
	/// @param {Real}	instanceID	The object within the current room to move.
	/// @param {Real}	x			New position along the x axis to move the instance to.
	/// @param {Real}	y			New position along the y axis to move the instnace to.
	cmd_move_object = function(_instanceID, _x, _y){
		if (!instance_exists(_instanceID)){
			history_add_line("ERROR -- Instance with ID value \"" + string(_instanceID) + "\" doesn't exist.");
			return;
		}
		
		// 
		var _prevX = 0;
		var _prevY = 0;
		with(_instanceID){
			_prevX	= string(x);
			_prevY	= string(y);
			x		= _x;
			y		= _y;
		}
		
		// 
		history_add_line("Instance \"" + string(_instanceID) + "\" was moved from (" + _prevX + ", " + _prevY + ") to (" + string(_x) + ", " + string(_y) + ")");
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/// PLAYER COMMAND FUNCTIONS //////////////////////////////////////////////////////////////////////////////////////
	
	/// @description Maxes out Samus's ammunition reserves for her missiles and power bombs.
	cmd_player_fill_ammo = function(){
		with(PLAYER){
			numMissiles		= maxMissiles;
			numPowerBombs	= maxPowerBombs;
		}
		history_add_line("Samus's ammunition reserves have been completely filled.");
	}
	
	/// @description Maxes out Samus's current energy, reserve energy, and aeion energy.
	cmd_player_fill_energy = function(){
		with(PLAYER){
			hitpoints			= maxHitpoints;
			reserveHitpoints	= maxReserveHitpoints;
			curAeion			= maxAeion;
		}
		history_add_line("Samus's current and reserve energy have been completely filled.\nHer aeion gauge has also been filled.");
	}
	
	/// @description Acting like an energy tank, this function will cause Samus's maximum energy to increase
	/// by the amount specified in the argument parameter. Note that this amount cannot be reduced.
	/// @param {Real}	modifier	Amount to increase Samus's maximum energy by if possible.
	cmd_player_increase_max_energy = function(_modifier){
		with(PLAYER) {update_maximum_energy(_modifier);}
		history_add_line("Samus's maximum energy has been increased by " + string(_modifier) + " units.");
	}
	
	/// @description Acting like an aeion tank, this function will cause Samus's maximum aeion energy capacity
	/// to increase by the value of the argument supplied. Note that this amount cannot be reduced.
	/// @param {Real}	modifier	Amount to increase Samus's maximum aeion amount by if possible.
	cmd_player_increase_max_aeion = function(_modifier){
		with(PLAYER) {update_maximum_aeion(_modifier);}
		history_add_line("Samus's maximum aeion has been increased by " + string(_modifier) + " units.");
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/// DEBUG COMMAND FUNCTIONS ///////////////////////////////////////////////////////////////////////////////////////
	
	/// @description Turns the debug info window on and off; allowing the user to see information about the
	/// game's performance, camera position, room info, and so on.
	cmd_toggle_debug_info = function(){
		var _windowVisible = false;
		with(DEBUGGER){ // Determine if the state bit to flip to 0 or 1 depending on what its current value is.
			_windowVisible = CAN_SHOW_WINDOW;
			if (_windowVisible) {stateFlags &= ~(1 << DBG_SHOW_WINDOW);}
			else				{stateFlags |=  (1 << DBG_SHOW_WINDOW);}
		}
		
		// Let the user know what state the debug info window was put into (Shown or not shown) since this
		// function doesn't take a "True" or "False" argument to determine its functionality.
		if (_windowVisible)	{history_add_line("Debug info will no longer be displayed on screen.");}
		else				{history_add_line("Debug info will now be displayed (Will not display if console is open).");}			
	}
	
	/// @description Toggles information about the program's current amount of time since launch, as well as
	/// the current game's playtime (This value exists on a per-save basis) from being displayed on the debug
	/// information window (As long as that window is visible) to not being displayed in said window (It is
	/// shown by default).
	cmd_debug_show_playtime = function(){
		with(DEBUGGER){
			if (CAN_SHOW_TIME)	{stateFlags &= ~(1 << DBG_SHOW_TIME);}
			else				{stateFlags |=  (1 << DBG_SHOW_TIME);}
		}
	}
	
	/// @description Toggles information about the current game state index as well as the previous one from
	/// being displayed on the debug information window (As long as that window is visible) to not being
	/// displayed in said window (It is shown by default).
	cmd_debug_show_game_state = function(){
		with(DEBUGGER){
			if (CAN_SHOW_GAME_STATE) {stateFlags &= ~(1 << DBG_SHOW_GAME_STATE);}
			else					 {stateFlags |=  (1 << DBG_SHOW_GAME_STATE);}
		}
	}
	
	/// @description Toggles information about the current FPS the game is running at (As well as the current
	/// value for the game's delta time value) from being displayed on the debug information window (As long
	/// as that window is visible) to not being displayed in said window (It is shown by default).
	cmd_debug_show_fps = function(){
		with(DEBUGGER){
			if (CAN_SHOW_FPS)	{stateFlags &= ~(1 << DBG_SHOW_FPS);}
			else				{stateFlags |=  (1 << DBG_SHOW_FPS);}
		}
	}
	
	/// @description Toggles information about the total number of entities and lights being actively rendered 
	/// from being displayed on the debug information window (As long as that window is visible) to not being
	/// displayed in said window (This is the default).
	cmd_debug_show_render_data = function(){
		with(DEBUGGER){
			if (CAN_SHOW_RENDER) {stateFlags &= ~(1 << DBG_SHOW_RENDER);}
			else				 {stateFlags |=  (1 << DBG_SHOW_RENDER);}
		}
	}
	
	/// @description Toggles information about the current room (Along with its width and height) and previous
	/// room from being displayed on the debug information window (As long as that window is visible) to not
	/// being displayed in said window (This is the default).
	cmd_debug_show_room_data = function(){
		with(DEBUGGER){
			if (CAN_SHOW_ROOM)	{stateFlags &= ~(1 << DBG_SHOW_ROOM);}
			else				{stateFlags |=  (1 << DBG_SHOW_ROOM);}
		}
	}
	
	/// @description Toggles information about the camera's size, position, and centerpoint within the current
	/// room from being displayed on the debug information window (As long as that window is visible) to not
	/// being displayed in said window (This is the default).
	cmd_debug_show_camera_data = function(){
		with(DEBUGGER){
			if (CAN_SHOW_CAMPOS) {stateFlags &= ~(1 << DBG_SHOW_CAMPOS);}
			else				 {stateFlags |=  (1 << DBG_SHOW_CAMPOS);}
		}
	}
	
	/// @description Toggles information about instance information (Number currently in the room, total amount
	/// of singletons, existing "struct objects", and so on) from being displayed on the debug information
	/// window (As long as that window is visible) to not being displayed in said window (This is the default).
	cmd_debug_show_instance_data = function(){
		with(DEBUGGER){
			if (CAN_SHOW_INSTANCES) {stateFlags &= ~(1 << DBG_SHOW_INSTANCES);}
			else					{stateFlags |=  (1 << DBG_SHOW_INSTANCES);}
		}
	}
	
	/// @description Toggles internal numerical information about the map system from being displayed on the
	/// debug information window (As long as that window is visible) to not being displayed in said window
	/// (This is the default).
	cmd_debug_show_map_data = function(){
		with(DEBUGGER){
			if (CAN_SHOW_MAP_INFO)	{stateFlags &= ~(1 << DBG_SHOW_MAP);}
			else					{stateFlags |=  (1 << DBG_SHOW_MAP);}
		}
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// -- General Commands -- //
	ds_list_add(commandKeys,	CMD_EXIT_GAME);
	ds_map_add(commandData,		CMD_EXIT_GAME, [
		"", cmd_exit_game
	]);
	ds_list_add(commandKeys,	CMD_GAME_STATE);
	ds_map_add(commandData,		CMD_GAME_STATE, [
		"", cmd_game_state
	]);
	ds_list_add(commandKeys,	CMD_TOGGLE_GODMODE);
	ds_map_add(commandData,		CMD_TOGGLE_GODMODE,	[
		"", cmd_toggle_godmode
	]);
	// -- Event Flag Commands -- //
	ds_list_add(commandKeys,	CMD_SET_EVENT_FLAG);
	ds_map_add(commandData,		CMD_SET_EVENT_FLAG, [
		"flagID: " + STRING_REAL + ", flagState: " + STRING_BOOL,
		cmd_set_event_flag, TYPE_REAL, TYPE_BOOL
	]);
	ds_list_add(commandKeys,	CMD_SHOW_EVENT_FLAGS);
	ds_map_add(commandData,		CMD_SHOW_EVENT_FLAGS, [
		"startBit: " + STRING_REAL + ", count: " + STRING_REAL,
		cmd_show_event_flags, TYPE_REAL, TYPE_REAL
	]);
	ds_list_add(commandKeys,	CMD_SHOW_ALL_FLAGS);
	ds_map_add(commandData,		CMD_SHOW_ALL_FLAGS, [
		"", cmd_show_all_event_flags
	]);
	// -- Entity Commands -- //
	ds_list_add(commandKeys,	CMD_SET_ENTITY_FLAG);
	ds_map_add(commandData,		CMD_SET_ENTITY_FLAG, [
		"entityID: " + STRING_REAL + ", flagID: " + STRING_REAL + ", flagState: " + STRING_BOOL,
		cmd_set_entity_flag, TYPE_REAL, TYPE_REAL, TYPE_BOOL
	]);
	// -- Object Commands -- //
	ds_list_add(commandKeys,	CMD_CREATE_OBJECT);
	ds_map_add(commandData,		CMD_CREATE_OBJECT, [
		"x: " + STRING_REAL + ", y: " + STRING_REAL + ", objectName: " + STRING_STRING,
		cmd_create_object, TYPE_REAL, TYPE_REAL, TYPE_STRING
	]);
	ds_list_add(commandKeys,	CMD_DESTROY_OBJECT);
	ds_map_add(commandData,		CMD_DESTROY_OBJECT, [
		"instanceID: " + STRING_REAL + ", performEvents: " + STRING_BOOL,
		cmd_destroy_object, TYPE_REAL, TYPE_BOOL
	]);
	ds_list_add(commandKeys,	CMD_MOVE_OBJECT);
	ds_map_add(commandData,		CMD_MOVE_OBJECT, [
		"instanceID: " + STRING_REAL + ", x: " + STRING_REAL + ", y: " + STRING_REAL,
		cmd_move_object, TYPE_REAL, TYPE_REAL, TYPE_REAL
	]);
	// -- Player Commands -- //
	ds_list_add(commandKeys,	CMD_PLAYER_FILL_AMMO);
	ds_map_add(commandData,		CMD_PLAYER_FILL_AMMO, [
		"", cmd_player_fill_ammo
	]);
	ds_list_add(commandKeys,	CMD_PLAYER_FILL_ENERGY);
	ds_map_add(commandData,		CMD_PLAYER_FILL_ENERGY, [
		"", cmd_player_fill_energy
	]);
	ds_list_add(commandKeys,	CMD_INCREASE_MAX_ENERGY);
	ds_map_add(commandData,		CMD_INCREASE_MAX_ENERGY, [
		"modifier: " + STRING_REAL,
		cmd_player_increase_max_energy, TYPE_REAL
	]);
	ds_list_add(commandKeys,	CMD_INCREASE_MAX_AEION);
	ds_map_add(commandData,		CMD_INCREASE_MAX_AEION, [
		"modifier: " + STRING_REAL,
		cmd_player_increase_max_aeion, TYPE_REAL
	]);
	// -- Debugger Commands -- //
	ds_list_add(commandKeys,	CMD_TOGGLE_DEBUG);
	ds_map_add(commandData,		CMD_TOGGLE_DEBUG, [
		"", cmd_toggle_debug_info
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_TIME);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_TIME, [
		"", cmd_debug_show_playtime
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_GSTATE);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_GSTATE, [
		"", cmd_debug_show_game_state
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_FPS);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_FPS, [
		"", cmd_debug_show_fps
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_RENDER);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_RENDER, [
		"", cmd_debug_show_render_data
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_ROOM);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_ROOM, [
		"", cmd_debug_show_room_data
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_CAMERA);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_CAMERA, [
		"", cmd_debug_show_camera_data
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_OBJECTS);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_OBJECTS, [
		"", cmd_debug_show_instance_data
	]);
	ds_list_add(commandKeys,	CMD_DEBUG_SHOW_MAP);
	ds_map_add(commandData,		CMD_DEBUG_SHOW_MAP, [
		"", cmd_debug_show_map_data
	]);
	// -- Shortcut Commands -- //
	ds_list_add(commandKeys,	CMD_TGM);
	ds_map_add(commandData,		CMD_TGM, [
		"", cmd_toggle_godmode
	]);
	ds_list_add(commandKeys,	CMD_TDW);
	ds_map_add(commandData,		CMD_TDW, [
		"", cmd_toggle_debug_info
	]);
}

#endregion

#region Global functions related to obj_console
#endregion