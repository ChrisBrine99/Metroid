#region Initializing any macros that are useful/related to obj_console

// Positions for the bits that represent states for various parts of the Console's functionality.
#macro	DRAW_CURSOR				28
#macro	FIRST_BACKSPACE			29
#macro	FIRST_CURSOR_MOVE		30
#macro	CONSOLE_ACTIVE			31

// Condenses the code required to check any of the Console's bit flags' current states into macro values.
#macro	CAN_DRAW_CURSOR			(stateFlags & (1 << DRAW_CURSOR) != 0)
#macro	IS_FIRST_BACKSPACE		(stateFlags & (1 << FIRST_BACKSPACE) != 0)
#macro	IS_FIRST_CURSOR_MOVE	(stateFlags & (1 << FIRST_CURSOR_MOVE) != 0)
#macro	IS_CONSOLE_ACTIVE		(stateFlags & (1 << CONSOLE_ACTIVE) != 0)

// -- General Commands -- //
#macro	CMD_EXIT_GAME			"exit_game"
#macro	CMD_GAME_STATE			"game_state"
// -- Event Flag Commands -- //
#macro	CMD_SET_EVENT_FLAG		"set_event_flag"
#macro	CMD_SHOW_EVENT_FLAGS	"show_event_flags"
#macro	CMD_SHOW_ALL_FLAGS		"show_all_event_flags"
// -- Object Commands -- //
#macro	CMD_CREATE_OBJECT		"create_object"
#macro	CMD_DESTROY_OBJECT		"destroy_object"
#macro	CMD_MOVE_OBJECT			"move_object"
// -- Player Data Commands -- //
#macro	CMD_PLAYER_FILL_AMMO	"player_fill_ammo"
#macro	CMD_PLAYER_FILL_ENERGY	"player_fill_energy"
#macro	CMD_INCREASE_MAX_ENERGY	"player_increase_max_energy"
#macro	CMD_INCREASE_MAX_AEION	"player_increase_max_aeion"
// -- Debugger Commands -- //
#macro	CMD_TOGGLE_DEBUG		"toggle_debug_window"
#macro	CMD_DEBUG_SHOW_TIME		"debug_show_playtime"
#macro	CMD_DEBUG_SHOW_GSTATE	"debug_show_game_state"
#macro	CMD_DEBUG_SHOW_FPS		"debug_show_fps"
#macro	CMD_DEBUG_SHOW_RENDER	"debug_show_render_data"
#macro	CMD_DEBUG_SHOW_ROOM		"debug_show_room_data"
#macro	CMD_DEBUG_SHOW_CAMERA	"debug_show_camera_data"
#macro	CMD_DEBUG_SHOW_OBJECTS	"debug_show_instance_data"

// -- Debugger Command Shortcuts -- //
#macro	CMD_TDI					"tdi"

// Stores the values used for the first backspace and the subsequent backspaces that occur afterward if the
// key is held for longer than that initial interval (60.0 = 1 second).
#macro	FIRST_BSPACE_INTERVAL	30.0
#macro	BSPACE_INTERVAL			1.75

// Like above, the macros here store the values for the first cursor shift, as well as the subsequent shifts
// should the left or right arrow keys be held down for longer than the first interval's duration. The third
// value dictates how fast the cursor will switch between visible and invisible.
#macro	FIRST_MOVE_INTERVAL		20.0
#macro	CURSOR_MOVE_INTERVAL	1.25
#macro	CURSOR_FLASH_INTERVAL	15.0

// Numerical codes for the three valid datatypes that the Console can utilize in its commands. These values
// are what the Console uses when parsing a command to determine what needs to be done before it can be used
// in the function being called by the user's command.
#macro	TYPE_REAL				5000
#macro	TYPE_BOOL				5001
#macro	TYPE_STRING				5002

// String representation for the three valid datatypes that the Console can utilize in its commands. This is
// what is shown to the user whenever they see an argument parameter in the suggestion data area.
#macro	STRING_REAL				"real"
#macro	STRING_BOOL				"bool"
#macro	STRING_STRING			"string"

// Stores the total limit of previous commands and text drawn to the Console's history window before the oldest
// lines begin to be discarded for new infomration.
#macro	HISTORY_DISPLAY_LIMIT	250

// 
#macro	MOUSE_WINDOW_WIDTH		140
#macro	MOUSE_WINDOW_HEIGHT		42

#endregion

#region Initializing any globals that are useful/related to obj_console
#endregion

#region The main object code for obj_console

/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function obj_console(_index) : base_struct(_index) constructor{
	// 
	stateFlags = (1 << FIRST_BACKSPACE) | (1 << FIRST_CURSOR_MOVE);
	
	// Stores whatever was typed by the used, which is then processed once they hit the enter key. It can be used
	// to get the value of an event flag, set or reset flags, create objects, destroy objects, and much more.
	command = "";
	
	// Stores all the commands that the user can type into the console in order to execute the function tied
	// to that command. The command name stores the array containing its function and required arguments.
	validCommands = ds_map_create();
	
	// Contains data for the Console's suggestion window, which displays what functions the user can potentially
	// type in relative to what they've already typed into the command window. The array cotains all the commands
	// and their arguments that are parsed to determine the suggestions to display to the user.
	suggestions		= ds_list_create();
	suggestionData	= [];
	
	// Variables for handling the Console's history window, which shows the 250 previous commands and information
	// that have been typed out by the user and displayed to the Console by the resulting command executions.
	history					= ds_list_create();
	historySurf				= -1;
	historyDisplayOffset	= 0;
	
	// Keeps track of the cursor's current position within the current string of command text that has been
	// typed into the console by the user.
	cursorPos = 1;
	
	// 
	mInstanceID		= noone;
	mInstanceName	= "";
	mInstanceIndex	= -1;
	mInstanceX		= 0;
	mInstanceY		= 0;
	
	// Stores the states for all entity objects prior to the console being opened, as well as the current and
	// previous game states from that time period as well (The Console sets the state to "PAUSED" which would
	// discard that other previous state without these storage variables).
	entityStates	= ds_map_create();
	gameCurState	= GSTATE_NONE;
	gamePrevState	= GSTATE_NONE;
	
	// Timers that are used for keeping track of the interval of time between the previous and next backspace,
	// cursor movement, and cursor flash, respectively.
	backspaceTimer	= 0.0;
	cursorMoveTimer = 0.0;
	cursorTimer		= 0.0;
	
	/// @description The standard cleanup function for the Console, which mimics how GameMaker's own "cleanup"
	/// event. As such, it should be called within the "cleanup" event by the controller object that manages
	/// this struct.
	cleanup = function(){
		ds_map_destroy(validCommands);
		ds_list_destroy(suggestions);
		ds_list_destroy(history);
		ds_map_destroy(entityStates);

		if (surface_exists(historySurf)) {surface_free(historySurf);}
	}
	
	/// @description The "End Step" function for the struct, which should be called in the "End Step" event of 
	/// the obejct that is set to managed this one. It will update the Console struct that is managed by the
	/// Debugger while also processing input logic for itself.
	end_step = function(){
		// 
		if (!IS_CONSOLE_ACTIVE){
			if (keyboard_check_pressed(vk_insert))
				enable_console_window();
			return;
		}
		
		// 
		if (keyboard_check_pressed(vk_insert)){
			disable_console_window();
			return;
		}
		
		// 
		cursorTimer += DELTA_TIME;
		if (cursorTimer >= CURSOR_FLASH_INTERVAL){
			if (CAN_DRAW_CURSOR) {stateFlags &= ~(1 << DRAW_CURSOR);}
			else				 {stateFlags |= (1 << DRAW_CURSOR);}
			cursorTimer = 0.0;
		}
		
		// 
		var _mouseMiddle = mouse_wheel_down() - mouse_wheel_up();
		if (_mouseMiddle != 0){
			historyDisplayOffset += _mouseMiddle * 5;
			if (historyDisplayOffset < 0) {historyDisplayOffset = 0;}
		}
		
		// 
		if (keyboard_check_pressed(vk_enter)){
			if (command != ""){ // Don't bother processing empty strings
				parse_current_command(command);
				ds_list_clear(suggestions);
			}
			keyboard_lastchar	= "";
			command				= "";
			cursorPos			= 1;
			return;
		}
		
		// 
		if (keyboard_check(vk_backspace) && cursorPos > 1){
			backspaceTimer -= DELTA_TIME;
			if (backspaceTimer <= 0.0){
				cursorPos--;
				command = string_delete(command, cursorPos, 1);
				if (command == "")	{ds_list_clear(suggestions);}
				else				{find_suggestions(command);}
				if (IS_FIRST_BACKSPACE){ // First backspace; longer duration before next character is deleted. 
					backspaceTimer	= FIRST_BSPACE_INTERVAL;
					stateFlags	   &= ~(1 << FIRST_BACKSPACE);
				} else{ // All subsequent backspaces, which are much faster than the initial one.
					backspaceTimer	= BSPACE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // Reset backspace variables to enable the longer first deletion interval again.
			stateFlags	   |= (1 << FIRST_BACKSPACE);
			backspaceTimer	= 0.0;
		}
		
		// 
		var _movement = keyboard_check(vk_right) - keyboard_check(vk_left);
		if (_movement != 0){
			cursorMoveTimer -= DELTA_TIME;
			if (cursorMoveTimer <= 0.0){
				if (_movement == 1 && cursorPos <= string_length(command))	{cursorPos++;}
				else if (_movement == -1 && cursorPos > 1)					{cursorPos--;}
				
				if (IS_FIRST_CURSOR_MOVE){ // Like the backspace code; the first movement will always have a longer duration until the next movement.
					stateFlags	   &= ~(1 << FIRST_CURSOR_MOVE);
					cursorMoveTimer = FIRST_MOVE_INTERVAL;
				} else{ // All subsequent cursor movements will move at a quick and regular interval.
					cursorMoveTimer = CURSOR_MOVE_INTERVAL;
				}
			}
			keyboard_lastchar = "";
			return;
		} else{ // 
			stateFlags	   |= (1 << FIRST_CURSOR_MOVE);
			cursorMoveTimer = 0.0;
		}
		
		// Adding the next key that was pressed at the end of the current string of command text. The variable
		// that stored the character that we added (A built-in GML variable) is cleared to prevent potential
		// duplication of a character when a non-character key is pressed.
		if (keyboard_lastkey != vk_nokey && keyboard_lastkey != vk_shift && keyboard_lastchar != ""){
			command = string_insert(keyboard_lastchar, command, cursorPos);
			find_suggestions(command);
			keyboard_lastkey	= vk_nokey;
			keyboard_lastchar	= "";
			stateFlags		   |= (1 << DRAW_CURSOR);
			cursorTimer			= 0.0;
			cursorPos++;
		}
		
		// 
		var _id = instance_position(mouse_x, mouse_y, all);
		if (_id == mInstanceID) {return;}
		
		// 
		var _name	= "";
		var _index	= -1;
		var _x		= 0;
		var _y		= 0;
		with(_id){
			_name	= object_get_name(object_index);
			_index	= object_index;
			_x		= x;
			_y		= y;
		}
		
		// Finally, take those copied values and place them into the matching variables contained within the
		// Console itself. Overall, this prevents the code jumping back and forth to copy these values one by
		// one and prevents having to cast each value to a string for every draw_gui call.
		mInstanceID		= string(real(_id));
		mInstanceName	= _name;
		mInstanceIndex	= string(_index);
		mInstanceX		= string(_x);
		mInstanceY		= string(_y);
	}
	
	/// @description 
	draw_gui = function(){
		if (!IS_CONSOLE_ACTIVE) {return;}
		
		// 
		var _cameraID		= CAMERA.camera;
		var _cameraWidth	= camera_get_view_width(_cameraID);
		var _cameraHeight	= camera_get_view_height(_cameraID);
		draw_sprite_ext(spr_rectangle, 0, 0, 0, _cameraWidth, _cameraHeight, 0, HEX_BLACK, 0.75);
		draw_sprite_ext(spr_rectangle, 0, 0, 163, _cameraWidth, 12, 0, HEX_DARK_GRAY, 0.5);
		
		// 
		shader_set_outline(font_gui_small, RGB_GRAY);
		draw_text_outline(3, 165, "> ", HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
		draw_text_outline(10, 165, command, HEX_WHITE, RGB_GRAY, 1);
		shader_reset();
		
		// 
		if (CAN_DRAW_CURSOR){
			var _cursorX = string_width(string_copy(command, 1, cursorPos - 1)) + 1;
			draw_sprite_ext(spr_rectangle, 0, 8 + _cursorX, 164, 1, 10, 0, HEX_LIGHT_YELLOW, 1);
		}
		
		// 
		var _start = ds_list_size(history) - 1;
		if (_start >= 0){
			if (!surface_exists(historySurf)){
				historySurf = surface_create(camera_get_view_width(_cameraID), camera_get_view_height(_cameraID) - 20);
			}
			
			// 
			shader_set_outline(font_gui_small, RGB_DARK_GRAY);
			surface_set_target(historySurf);
			draw_clear_alpha(c_black, 0);
			var _text;
			var _yOffset = -historyDisplayOffset;
			for (var i = _start; i >= 0; i--){
				if (_yOffset >= 180) {break;} // Don't bother drawing anything that is above the currently visible history region.
				_text = history[| i];
				_yOffset += string_height(_text);
				if (_yOffset < 0) {continue;} // Skips over text that would be rendered below the history region.
				draw_text_outline(5, 160 - _yOffset, _text, HEX_GRAY, RGB_DARK_GRAY, 1);
				_yOffset += 2;
			}
			surface_reset_target();
			shader_reset();
			draw_surface(historySurf, 0, 0);
		}
		
		// 
		var _suggestionSize = ds_list_size(suggestions);
		if (_suggestionSize > 0){
			draw_sprite_ext(spr_rectangle, 0, 5, 163, _cameraWidth - 10, -(_suggestionSize * 11) - 3, 0, HEX_DARK_GRAY, 1);
			
			var _yy = 152;
			shader_set_outline(font_gui_small, RGB_DARK_YELLOW);
			for (var i = 0; i < _suggestionSize; i++){
				if (_yy <= 0) {break;} // Exit to prevent drawing suggestions that will be drawn off of the screen's visible region.
				draw_text_outline(10, _yy, suggestionData[suggestions[| i]], HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
				_yy -= 11;
			}
			shader_reset();
		}
		
		// 
		var _mouseScreenX = mouse_x - camera_get_view_x(_cameraID);
		var _mouseScreenY = mouse_y - camera_get_view_y(_cameraID);
		draw_sprite_ext(spr_rectangle, 0, _mouseScreenX, _mouseScreenY, 1, 1, 0, HEX_WHITE, 1);
		if (mInstanceID == noone) {return;}
		
		// 
		var _limitX = min(_mouseScreenX + 1, _cameraWidth - MOUSE_WINDOW_WIDTH - 1);
		var _limitY = min(_mouseScreenY + 1, _cameraHeight - MOUSE_WINDOW_HEIGHT - 1);
		draw_sprite_ext(spr_rectangle, 0, _limitX, _limitY, MOUSE_WINDOW_WIDTH, MOUSE_WINDOW_HEIGHT, 0, HEX_BLACK, 0.75); 
		draw_sprite_ext(spr_rectangle, 0, _limitX, _limitY, MOUSE_WINDOW_WIDTH, 12, 0, HEX_DARK_GRAY, 0.25);
	
		// 
		shader_set_outline(font_gui_small, RGB_DARK_YELLOW);
		draw_text_outline(_limitX + 3, _limitY + 15, "Instance ID\nObject Index\nPosition", HEX_WHITE, RGB_GRAY, 1);
		draw_set_halign(fa_right);
		
		// 
		var _dataX = _limitX + MOUSE_WINDOW_WIDTH - 3;
		draw_text_outline(_dataX, _limitY + 2, mInstanceName, HEX_RED, RGB_DARK_RED, 1);
		draw_text_outline(_dataX, _limitY + 15, 
			mInstanceID + "\n" + mInstanceIndex + "\n[" + mInstanceX + ", " + mInstanceY + "]", 
				HEX_LIGHT_YELLOW, RGB_DARK_YELLOW, 1);
		
		draw_set_halign(fa_left);
		shader_reset();
	}
	
	/// @description Opens up the Console's main window, which allows the user to input commands via the 
	/// keyboard to execute functions that assist with the debugging process. On top of that, the mouse cursor 
	/// can be used to check instance information by hovering over a given object.
	enable_console_window = function(){
		var _entityStates	= entityStates; // Copy index of ds_map for quick reference while in Entity scope.
		var _curState		= NO_STATE;
		var _nextState		= NO_STATE;
		var _lastState		= NO_STATE;
		with(par_dynamic_entity){
			_curState		= curState;
			_nextState		= nextState;
			_lastState		= lastState;
			
			// 
			ds_map_add(_entityStates, id, {
				curState	: _curState,
				nextState	: _nextState,
				lastState	: _lastState
			});
			
			// 
			stateFlags |= (1 << FREEZE_ANIMATION);
			curState	= NO_STATE;
			nextState	= NO_STATE;
			lastState	= NO_STATE;
		}
		
		// 
		stateFlags		   |= (1 << CONSOLE_ACTIVE) | (1 << FIRST_BACKSPACE) | (1 << FIRST_CURSOR_MOVE) | (1 << DRAW_CURSOR);
		gameCurState		= GAME_CURRENT_STATE;
		gamePrevState		= GAME_PREVIOUS_STATE;
		command				= "";	// Remove anything that was previous typed as a command.
		cursorPos			= 1;
		backspaceTimer		= 0.0;	// Clear all timer variable values.
		cursorMoveTimer		= 0.0;
		cursorTimer			= 0.0;
		
		// 
		keyboard_lastchar	= "";
		game_set_state(GSTATE_PAUSED);
	}
	
	/// @description 
	disable_console_window = function(){
		var _key			= ds_map_find_first(entityStates);
		var _stateStruct	= noone;
		var _curState		= NO_STATE;
		var _nextState		= NO_STATE;
		var _lastState		= NO_STATE;
		while(!is_undefined(_key)){
			// 
			_stateStruct	= entityStates[? _key];
			with(_stateStruct){
				_curState	= curState;
				_nextState	= nextState;
				_lastState	= lastState;
			}
			
			// 
			with(_key){
				stateFlags &= ~(1 << FREEZE_ANIMATION);
				curState	= _curState;
				nextState	= _nextState;
				lastState	= _lastState;
			}
			_key = ds_map_find_next(entityStates, _key);
			delete _stateStruct; // Signal to GameMaker that the struct can be cleared from memory.
		}
		
		// 
		stateFlags &= ~(1 << CONSOLE_ACTIVE);
		game_set_state(gameCurState, true);
		ds_map_clear(entityStates);
		ds_list_clear(suggestions);
	}
	
	/// @description Attempts to parse out the command data that was typed in by the user. It will find the
	/// required function and any arguments that the function may require. Any errors within this process will
	/// display a failure message in order to let the user know where they messed up in the command.
	/// @param {String}	command		The data that was typed into the console command line by the user.
	parse_current_command = function(_command){
		var _funcString = _command;
		var _firstSpace = string_pos(CHAR_SPACE, _funcString);
		if (_firstSpace > 0) {_funcString = string_copy(_command, 1, _firstSpace - 1);}
		history_add_line("> " +_command); // Display the command that was typed into the console's history.
		
		// Check if a function exists for what the user typed in prior to the first space (That space denotes
		// arguments from that point onward). If no function exists, the command will be discarded.
		var _data = ds_map_find_value(validCommands, string_lower(_funcString));
		if (is_undefined(_data)){
			history_add_line("ERROR -- Command \"" + _funcString + "\" does not exist.");
			return;
		}
		
		// Determine if arguments exist for the function or not by checking the length of the array containing
		// the command's function information. If the size is greater than 1, argument parsing will occur.
		var _length = array_length(_data);
		if (_length > 1){
			// Copy over all the arguments supplied by the user in their command. Then, create a temporary
			// array that will store the datatypes required for each argument in the command so the function
			// parsing this data knows what to look for.
			var _argString = string_copy(_command, _firstSpace + 1, string_length(_command));
			var _datatypes = [];
			array_copy(_datatypes, 0, _data, 1, _length - 1);
			
			// Call the function that parses the arguments from "_argString". This will return an array where
			// all values are the proper datatype; it will be the same length as the "_datatypes" array should
			// the parsing process have been successful.
			var _arguments = get_arguments_from_string(_argString, _datatypes);
			if (array_length(_arguments) < array_length(_datatypes)){
				history_add_line("Argument Error: \n" + string(_datatypes) + "\n" + string(_arguments));
				return;
			}
			script_execute_ext(method_get_index(_data[0]), _arguments);
		} else{ // Simply call the requested function.
			_data[0]();
		}
	}
	
	/// @description Takes in the remainder of the "command" string and attempts to parse out the required
	/// arguments for the function that the user is attempting to call. A failure of this function's execution
	/// will return an array that doesn't equal in length to the number of arguments required by the function.
	/// @param {String}			string		Contains all of the function's required arguments; separated by spaces.
	/// @param {Array<Real>}	datatypes	A copy of the datatypes required by the function, which determines how each argument is parsed.
	get_arguments_from_string = function(_string, _datatypes){
		var _argString		= "";
		var _argStringExt	= "";
		var _length			= array_length(_datatypes);
		var _currentArg		= 0;
		var _arguments		= [];
		var _spacePos		= 1;
		var _index			= 1;
		while(_currentArg < _length){
			// Grab the position of the next space between the arguments OR the last character's index value
			// due to it not having anymore arguments so the copying of the substring works as it should
			// (Using "string_pos_ext" for both scenarios would result in "_spacePos" being set to 0 for 
			// the final argument due to no space character existing past that last argument).
			if (_currentArg >= _length - 1)	{_spacePos = string_length(_string) + 1;}
			else							{_spacePos = string_pos_ext(CHAR_SPACE, _string, _index);}
			
			// Parse the string that is pulled from the arguments depending on the datatype required by the 
			// function that is set to be called after this function.
			_argString = string_copy(_string, _index, _spacePos - _index);
			switch(_datatypes[_currentArg]){
				case TYPE_REAL: // Convert the string argument into a number and place it into the argument array.
					if (_argString == ""){
						history_add_line("ERROR -- Invalid input for type \"real\". Aborting command processing...");
						return _arguments;
					}
					_arguments[_currentArg] = real(_argString);
					break;
				case TYPE_BOOL: // Replace the "true" or "false" string with their GML constant equivalents.
					_argStringExt = string_lower(_argString);
					if (_argStringExt == "true")		{_arguments[_currentArg] = true;}
					else if (_argStringExt == "false")	{_arguments[_currentArg] = false;}
					break;
				case TYPE_STRING: // The argument is already a string; simply place it into the argument array.
					_arguments[_currentArg] = _argString;
					break;
			}
			_index = _spacePos + 1;
			_currentArg++;
		}
		return _arguments;
	}
	
	/// @description Appends a line onto the ds_list that represents the Console's command/information history.
	/// Should the total number of values exceed the history's display limit, the oldest piece of information
	/// will be discarded to make room for the newest value.
	/// @param {String}	string	The line of text that will be added into the Console's history.
	history_add_line = function(_string){
		if (ds_list_size(history) >= HISTORY_DISPLAY_LIMIT) {ds_list_delete(history, 0);}
		ds_list_add(history, _string);
	}
	
	/// @description Look through the Console's "suggestionData" array to see which values should be displayed
	/// to help the user see what commands they can input relative to the current text they've typed into the
	/// Console's input section.
	/// @param {String}	string	The line of text that the user typed into the Console's input window.
	find_suggestions = function(_string){
		// Ensures that the proper function along with its argument types won't disappear once the user 
		// starts inputting arguments; as the suggestion will disappear as the argument data doesn't match
		// the string data representing those argument types in the suggestion data.
		if (string_count(" ", _string) > 0) {_string = string_copy(_string, 1, string_pos(" ", _string));}
		
		// Loop through the list of suggestion data that can be displayed to the user; adding everything
		// that contains the current command that has been typed in to the list that is then displayed on
		// screen to show the user functions they may want to use based on said command string.
		ds_list_clear(suggestions);
		var _arraySize = array_length(suggestionData);
		var _length = _arraySize * 0.5;
		for (var i = 0; i < _length; i++){
			if (string_count(_string, suggestionData[i]) > 0)
				ds_list_add(suggestions, i);
			else if (string_count(_string, suggestionData[_arraySize - i - 1]) > 0)
				ds_list_add(suggestions, _arraySize - i - 1);
		}
	}
	
	/// @description A very simple command that will execute the game's end; closing the application and 
	/// running all existing objects "cleanup" functions to clear any manually allocated memory in the game.
	cmd_exit_game = function(){
		game_end();
	}
	
	/// @description A simple function that displays the game's current state and its previous state (Whatever 
	/// they were set to prior to the console being opened due to it setting the current state to "paused").
	cmd_game_state = function(){
		var _gameState = "Current State: " + game_state_get_name(gameCurState) + "\nPrevious State: " + game_state_get_name(gamePrevState);
		history_add_line(_gameState);
	}
	
	/// @description Allows the setting/resetting of a desired flag to either 1 (true) or 0 (false), which will
	/// determine if certain objects (Ex. Collectibles) exist within the world or not, if special doorwars are
	/// locked or not, and so on.
	/// @param {Real}	flagID		The ID of the flag that is being manipulated.
	/// @param {Bool}	flagState	The state to set the flag bit to (1 = true, 0 = false).
	cmd_set_event_flag = function(_flagID, _flagState){
		var _flagInfo = "Flag with ID (" + string(_flagID) + ") was set to " + string(_flagState);
		history_add_line(_flagInfo);
		event_set_flag(_flagID, _flagState);
	}
	
	/// @description Displays a given range of bits found within the "global.eventFlags" buffer. It will space
	/// each bit into 8 bit groups; creating a new line once 32 bits have been displayed on a single line.
	/// @param {Real}	startBit	The bit that will be the first bit displayed to the console.
	/// @param {Real}	range		The total number of bits to display relative to the starting bit.	
	cmd_show_event_flags = function(_startBit, _range){
		if (_range <= 0){ // The range provided is an invalid number; no bits can be shown as a result.
			history_add_line("ERROR -- Invalid value for range specified (Must be > 0).");
			return; // Command will not be executed due to error.
		} else if (_startBit < 0 || _startBit >= TOTAL_EVENT_FLAG_BYTES * 8){ // Chosen start bit is outside the range of valid bit indexes.
			history_add_line("ERROR -- Starting bit is outside the valid range of event flags (Valid indexes: 0 to " + string((TOTAL_EVENT_FLAG_BYTES * 8) - 1) + ").");
			return; // Command will not be executed due to error.
		}
		
		var _eventFlags = "";
		for (var i = _startBit; i < _startBit + _range; i++){
			if (i > _startBit){ // Conditions to format the bits shown by the console for readability.
				var _iValue = i - _startBit;
				if ((_iValue % 8) == 0)		{_eventFlags += " ";}
				if ((_iValue % 32) == 0)	{_eventFlags += "\n";}
			}
			_eventFlags += string(event_get_flag(i));
		}
		history_add_line(_eventFlags);
	}
	
	/// @description A simplified version of the above function that will display ALL event flag bits; both used
	/// and unused. The main difference between this and the "show_event_flags" function is the bits here will
	/// be grouped based on what they represent: items, doorways, other, etc..
	cmd_show_all_event_flags = function(){
		history_add_line("Suit Upgrades (Bits 0 and 1):\n" // Displaying flags that alter Samus's suit.
			+ string(event_get_flag(FLAG_VARIA_SUIT)) 
			+ string(event_get_flag(FLAG_GRAVITY_SUIT))
		);
		
		history_add_line("Jump Upgrades (Bits 2 to 4):\n" // Displaying all upgrades to Samus's jumping capabilities.
			+ string(event_get_flag(FLAG_HIJUMP_BOOTS))
			+ string(event_get_flag(FLAG_SPACE_JUMP))
			+ string(event_get_flag(FLAG_SCREW_ATTACK))
		);
		
		var _eventFlags = ""; // Displaying all upgrade flags for Samus's arm cannon.
		for (var i = FLAG_ICE_BEAM; i < FLAG_ENERGY_SHIELD; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Beam Upgrades (Bits 5 to 9):\n" + _eventFlags);
		
		history_add_line("Aeion Upgrades (Bits 10 to 12):\n" // Displaying acquired aeion abilities that Samus has access to.
			+ string(event_get_flag(FLAG_ENERGY_SHIELD))
			+ string(event_get_flag(FLAG_PHASE_SHIFT))
			+ string(event_get_flag(FLAG_SCAN_PULSE))
		);
		
		_eventFlags = ""; // Displaying all currently active morphball upgrades.
		for (var i = FLAG_MORPHBALL; i < FLAG_MISSILES; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Morphball Upgrades (Bits 13 to 18):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all acquired missile upgrades.
		for (var i = FLAG_MISSILES; i < FLAG_LOCK_ON_MISSILES + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Missile Upgrades (Bits 19 to 23):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all small missile tanks Samus has collected.
		for (var i = SMALL_MISSILE_TANK0; i < LARGE_MISSILE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Small Missile Tanks (Bits 32 to 91):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all large missile tanks Samus has collected.
		for (var i = LARGE_MISSILE_TANK0; i < POWER_BOMB_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Large Missile Tanks (Bits 92 to 103):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all power bombs Samus has collected.
		for (var i = POWER_BOMB_TANK0; i < ENERGY_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Power Bomb Tanks (Bits 104 to 115):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tanks Samus has collected.
		for (var i = ENERGY_TANK0; i < ENERGY_TANK_PIECE0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tanks (Bits 116 to 123):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all energy tank pieces Samus has collected.
		for (var i = ENERGY_TANK_PIECE0; i < RESERVE_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Energy Tank Pieces (Bits 124 to 137):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all reserve tanks Samus has collected.
		for (var i = RESERVE_TANK0; i < AEION_TANK0; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Reserve Tanks (Bits 138 to 141):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all aeion tanks Samus has collected.
		for (var i = AEION_TANK0; i < AEION_TANK0 + 4; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Aeion Tanks (Bits 142 to 145):\n" + _eventFlags);
		
		_eventFlags = ""; // Displaying all "special" door flags.
		for (var i = FLAG_SPECIAL_DOOR0; i < FLAG_SPECIAL_DOOR0 + 1; i++) {_eventFlags += string(event_get_flag(i));}
		history_add_line("Unlocked Doors (Bits 150 to 150):\n" + _eventFlags);
	}
	
	/// @description 
	/// @param {Real}	x
	/// @param {Real}	y
	/// @param {String}	objectName
	cmd_create_object = function(_x, _y, _objectName){
		// 
		if (asset_get_type(_objectName) != asset_object){
			history_add_line("ERROR -- Asset with provided name isn't of type object.");
			return;
		}
		
		// 
		var _index	= asset_get_index(_objectName);
		if (_index == -1){
			history_add_line("ERROR -- Asset with the name \"" + _objectName + "\" doesn't exist!");
			return;
		}
		
		// 
		var _instance = real(instance_create_object(_x, _y, _index));
		history_add_line("Instance of \"" + _objectName + "\" (ID: " + string(_instance) + ") has been created.");
	}
	
	/// @description 
	/// @param {Real}	instanceID		Unique value pointing to the object we want to destroyed.
	/// @param {Bool}	performEvents	Toggles the call to the object's "Destroy" event on/off.
	cmd_destroy_object = function(_instanceID, _performEvents){
		if (!instance_exists(_instanceID)){
			history_add_line("ERROR -- Instance with ID value \"" + string(_instanceID) + "\" doesn't exist.");
			return;
		}
		
		// 
		var _oName = -1;
		with(_instanceID){
			_oName = object_get_name(object_index);
			instance_destroy_object(id, _performEvents);
		}
		
		// 
		if (_performEvents) {history_add_line("Instance of \"" + _oName + "\" with ID " + string(_instanceID) + " has been destroyed.\nIts destroy event was processed.");}
		else {history_add_line("Instance of \"" + _oName + "\" with ID " + string(_instanceID) + " has been destroyed.\nIts destroy event was skipped.");}
	}
	
	/// @description 
	/// @param {Real}	instanceID	The object within the current room to move.
	/// @param {Real}	x			New position along the x axis to move the instance to.
	/// @param {Real}	y			New position along the y axis to move the instnace to.
	cmd_move_object = function(_instanceID, _x, _y){
		if (!instance_exists(_instanceID)){
			history_add_line("ERROR -- Instance with ID value \"" + string(_instanceID) + "\" doesn't exist.");
			return;
		}
		
		// 
		var _prevX = 0;
		var _prevY = 0;
		with(_instanceID){
			_prevX	= string(x);
			_prevY	= string(y);
			x		= _x;
			y		= _y;
		}
		
		// 
		history_add_line("Instance \"" + string(_instanceID) + "\" was moved from (" + _prevX + ", " + _prevY + ") to (" + string(_x) + ", " + string(_y) + ")");
	}
	
	/// @description Maxes out Samus's ammunition reserves for her missiles and power bombs.
	cmd_player_fill_ammo = function(){
		with(PLAYER){
			numMissiles		= maxMissiles;
			numPowerBombs	= maxPowerBombs;
		}
		history_add_line("Samus's ammunition reserves have been completely filled.");
	}
	
	/// @description Maxes out Samus's current energy, reserve energy, and aeion energy.
	cmd_player_fill_energy = function(){
		with(PLAYER){
			hitpoints			= maxHitpoints;
			reserveHitpoints	= maxReserveHitpoints;
			curAeion			= maxAeion;
		}
		history_add_line("Samus's current and reserve energy have been completely filled.\nHer aeion gauge has also been filled.");
	}
	
	/// @description Acting like an energy tank, this function will cause Samus's maximum energy to increase
	/// by the amount specified in the argument parameter. Note that this amount cannot be reduced.
	/// @param {Real}	modifier	Amount to increase Samus's maximum energy by if possible.
	cmd_player_increase_max_energy = function(_modifier){
		with(PLAYER) {update_maximum_energy(_modifier);}
		history_add_line("Samus's maximum energy has been increased by " + string(_modifier) + " units.");
	}
	
	/// @description Acting like an aeion tank, this function will cause Samus's maximum aeion energy capacity
	/// to increase by the value of the argument supplied. Note that this amount cannot be reduced.
	/// @param {Real}	modifier	Amount to increase Samus's maximum aeion amount by if possible.
	cmd_player_increase_max_aeion = function(_modifier){
		with(PLAYER) {update_maximum_aeion(_modifier);}
		history_add_line("Samus's maximum aeion has been increased by " + string(_modifier) + " units.");
	}
	
	/// @description Turns the debug info window on and off; allowing the user to see information about the
	/// game's performance, camera position, room info, and so on.
	cmd_toggle_debug_info = function(){
		var _windowVisible = false;
		with(DEBUGGER){ // Determine if the state bit to flip to 0 or 1 depending on what its current value is.
			_windowVisible = CAN_SHOW_WINDOW;
			if (_windowVisible) {stateFlags &= ~(1 << DBG_SHOW_WINDOW);}
			else				{stateFlags |= (1 << DBG_SHOW_WINDOW);}
		}
		
		// Let the user know what state the debug info window was put into (Shown or not shown) since this
		// function doesn't take a "True" or "False" argument to determine its functionality.
		if (_windowVisible)	{history_add_line("Debug info will not be displayed on screen.");}
		else				{history_add_line("Debug info will now be displayed (Will not display if console is open).");}			
	}
	
	/// @description Toggles the playtime and total program time section of the debug information window on 
	/// or off depending on the value supplied in the argument parameter.
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_playtime = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_TIME);}
			else				{stateFlags &= ~(1 << DBG_SHOW_TIME);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_game_state = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_GAME_STATE);}
			else				{stateFlags &= ~(1 << DBG_SHOW_GAME_STATE);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_fps = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_FPS);}
			else				{stateFlags &= ~(1 << DBG_SHOW_FPS);}
		}
	}
	
	/// @description Allows the user to toggle whether or not information about entity and light source 
	/// rendering--the number of each rendered for the current frame--is displayed in the debug info window.
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_render_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_RENDER);}
			else				{stateFlags &= ~(1 << DBG_SHOW_RENDER);}
		}
	}
	
	/// @description Allows the user to enable or disable the section on the debug info window that displays 
	/// the name of both the current and previous room, respectively.
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_room_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_ROOM);}
			else				{stateFlags &= ~(1 << DBG_SHOW_ROOM);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_camera_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_CAMPOS);}
			else				{stateFlags &= ~(1 << DBG_SHOW_CAMPOS);}
		}
	}
	
	/// @description 
	/// @param {Bool}	displayInfo		Determines if this information should show up in the debug info window.
	cmd_debug_show_instance_data = function(_displayInfo){
		with(DEBUGGER){
			if (_displayInfo)	{stateFlags |= (1 << DBG_SHOW_INSTANCES);}
			else				{stateFlags &= ~(1 << DBG_SHOW_INSTANCES);}
		}
	}

	// Initialize the suggestion data array, which contains a string representation of a given command along
	// with its argument parameters contained within square brackets. These arguments have a name and denote
	// their datatype so the user knows what the commands expects as input.
	array_push(suggestionData,
		// -- General Commands -- //
		CMD_EXIT_GAME				+ " []",
		CMD_GAME_STATE				+ " []",
		// -- Event Flag Commands -- //
		CMD_SET_EVENT_FLAG			+ " [ flagID: " + STRING_REAL + ", flagState: " + STRING_BOOL + " ]",
		CMD_SHOW_EVENT_FLAGS		+ " [ start: " + STRING_REAL + ", range: " + STRING_REAL + " ]",
		CMD_SHOW_ALL_FLAGS			+ " []",
		// -- Object Commands -- //
		CMD_CREATE_OBJECT			+ " [ x: " + STRING_REAL + ", y: " + STRING_REAL + ", name: " + STRING_STRING + "]",
		CMD_DESTROY_OBJECT			+ " [ instanceID: " + STRING_REAL + ", performEvents: " + STRING_BOOL + "]",
		CMD_MOVE_OBJECT				+ " [ instanceID: " + STRING_REAL + ", x: " + STRING_REAL + ", y: " + STRING_REAL + "]",
		// -- Player Data Commands -- //
		CMD_PLAYER_FILL_AMMO		+ " []",
		CMD_PLAYER_FILL_ENERGY		+ " []",
		CMD_INCREASE_MAX_ENERGY		+ " [ modifier: " + STRING_REAL + " ]",
		CMD_INCREASE_MAX_AEION		+ " [ modifier: " + STRING_REAL + " ]",
		// -- Debugger Commands -- //
		CMD_TOGGLE_DEBUG			+ " []",
		CMD_DEBUG_SHOW_TIME			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_GSTATE		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_FPS			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_RENDER		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_ROOM			+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_CAMERA		+ " [ showInfo: " + STRING_BOOL + " ]",
		CMD_DEBUG_SHOW_OBJECTS		+ " [ showInfo: " + STRING_BOOL + " ]",
	);
	
	// -- General Commands -- //
	ds_map_add(validCommands, CMD_EXIT_GAME,			[cmd_exit_game]);
	ds_map_add(validCommands, CMD_GAME_STATE,			[cmd_game_state]);
	// -- Event Flag Commands -- //
	ds_map_add(validCommands, CMD_SET_EVENT_FLAG,		[cmd_set_event_flag, TYPE_REAL, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_SHOW_EVENT_FLAGS,		[cmd_show_event_flags, TYPE_REAL, TYPE_REAL]);
	ds_map_add(validCommands, CMD_SHOW_ALL_FLAGS,		[cmd_show_all_event_flags]);
	// -- Object Commands -- //
	ds_map_add(validCommands, CMD_CREATE_OBJECT,		[cmd_create_object, TYPE_REAL, TYPE_REAL, TYPE_STRING]);
	ds_map_add(validCommands, CMD_DESTROY_OBJECT,		[cmd_destroy_object, TYPE_REAL, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_MOVE_OBJECT,			[cmd_move_object, TYPE_REAL, TYPE_REAL, TYPE_REAL]);
	// -- Player Data Commands -- //
	ds_map_add(validCommands, CMD_PLAYER_FILL_AMMO,		[cmd_player_fill_ammo]);
	ds_map_add(validCommands, CMD_PLAYER_FILL_ENERGY,	[cmd_player_fill_energy]);
	ds_map_add(validCommands, CMD_INCREASE_MAX_ENERGY,	[cmd_player_increase_max_energy, TYPE_REAL]);
	ds_map_add(validCommands, CMD_INCREASE_MAX_AEION,	[cmd_player_increase_max_aeion, TYPE_REAL]);
	// -- Debugger Commands -- //
	ds_map_add(validCommands, CMD_TOGGLE_DEBUG,			[cmd_toggle_debug_info]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_TIME,		[cmd_debug_show_playtime, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_GSTATE,	[cmd_debug_show_game_state, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_FPS,		[cmd_debug_show_fps, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_RENDER,	[cmd_debug_show_render_data, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_ROOM,		[cmd_debug_show_room_data, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_CAMERA,	[cmd_debug_show_camera_data, TYPE_BOOL]);
	ds_map_add(validCommands, CMD_DEBUG_SHOW_OBJECTS,	[cmd_debug_show_instance_data, TYPE_BOOL]);
	// -- Debugger Command Shortcuts -- //
	ds_map_add(validCommands, CMD_TDI,					[cmd_toggle_debug_info]);
}

#endregion

#region Global functions related to obj_console
#endregion