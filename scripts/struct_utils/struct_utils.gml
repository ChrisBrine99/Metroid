/// @description A basic struct that all others must inherit from (So long as they use the "constructor" 
/// moniker and aren't created and assigned to local variables within an object/struct upon said object/struct's 
/// creation). This means all structs will have their own initialize and cleanup functions regardless of if 
/// they inherit them for their own use or not.
/// @param {Real} index		Unique value generated by GML during compilation that represents this struct asset.
function base_struct(_index) constructor{
	id = global.structID;
	object_index = _index;

	initialize = function(){}
	cleanup = function(){}
}

/// @description Creates a new struct object in a way that mimics how GameMaker creates and handles its own
/// object instances; storing a unique id indentifier value to a struct upon creation for easy reference of
/// a single instance or instances of that struct. Singleton structs will not be able to be created by this
/// function if an instance of them already exists in the game.
/// @param {Struct}	struct	The struct object to be instantiated by GameMaker.
function instance_create_struct(_struct){
	if (!singleton_instance_exists(_struct)){
		var _instance = new _struct(_struct);
		_instance.initialize(); // Every instance overrides this function from the base struct.
		
		ds_list_add(global.structs, _instance);
		global.structID++; // Increment the ID so the next struct never has the same ID as a previous one.
		
		return _instance;
	}
	return noone;
}

/// @description A function that mimics how GameMaker's own "instance_destroy" function works, but focuses on
/// the deletion of structs that exist within the game currently. Singleton structs are not allowed to be
/// deleted by this function; as they generally exist for the entire duration of the game's runtime.
/// @param {Struct}	instance	The struct instance that will be marked for deletion by GameMaker's garbage collector.
function instance_destroy_struct(_instance){
	var _index = ds_list_find_index(global.structs, _instance);
	if (_index == -1 || singleton_instance_exists(_instance.object_index)) 
			return;
	ds_list_delete(global.structs, _index);
	_instance.cleanup();
	delete _instance;
}

/// @description Finds the struct instance with the designated ID given as the function's argument; returning
/// the reference to that struct so the variables and method within can be referenced if required. If a struct
/// with that ID cannot be found, the function will return "noone" to signify an invalid instance.
/// @param {Id.Instance}	id
function instance_find_struct(_id){
	// Grab the current size of the struct mangement list. Then, check if the list is even containing data. If
	// it isn't, the default value of noone to let GameMaker know no instance with that ID exists. If a single
	// struct exists and its ID doesn't match the argument the same default value will be returned.
	var _length = ds_list_size(global.structs);
	var _match	= (_length == 1 && global.structs[| 0].id == _id);
	if (_length == 0 || !_match)
		return noone;
	
	// If the single existing struct's ID check managed to pass, the reference to that struct is returned here 
	// to avoid  having to process all the instructions required for setting up the binary search loop below.
	if (_match)
		return global.structs[| 0];
	
	// Perform a binary search of the current structs that exist within the game. The loop exists early upon
	// the matching ID being found, and will loop through the entire list should the ID never be found.
	var _struct	= noone;
	var _first	= 0;
	var _second = _length - 1;
	while(_first <= _second){
		_struct = global.structs[| _first];
		if (_struct.id == _id) // First index's struct has the matching ID; return that struct.
			return _struct;
		
		// Exits out of the loop prematurely to avoid a second check on the same struct (This occurs whenever
		// the signs of the two index values match at the end of the binary search) if the ID didn't match.
		if (_first == _second)
			break;
			
		_struct = global.structs[| _second];
		if (_struct.id == _id) // Second index's struct has the matching ID; return that struct. 
			return _struct;
		
		// Increment the first index and decrement the second index value. The loop exits when these values
		// are equal (Occurs whenever both values are even or odd) or the first value has exceeded the value
		// of the second index (Occurs whenever one value is even and the other is odd).
		_first++;
		_second--;
	}
	
	// The struct with the matching ID value couldn't be found; return the default no instance value.
	return noone;
}

/// @description Finds where the desired struct instance is placed within the management list for all currently
/// existing instances of structs within the game. If no instance is found, the function will return a -1 to
/// signify no valid index was found.
/// @param {Id.Instance}	id
function instance_find_struct_index(_id){
	// Grab the current size of the struct mangement list. Then, check if the list is even containing data. If
	// it isn't, the default value of -1 is returned to signify a failure. Another check is done to see if the
	// length is one but the id doesn't match, which will also return the default value.
	var _length = ds_list_size(global.structs);
	var _match	= (_length == 1 && global.structs[| 0].id == _id);
	if (_length == 0 || !_match)
		return -1;
		
	// If the single existing struct's ID check managed to pass, the value of 0 is returned here to avoid 
	// having to process all the instructions required for setting up the binary search loop below.
	if (_match)
		return 0;
	
	// Perform a binary search of the current structs that exist within the game. The loop exists early upon
	// the matching ID being found, and will loop through the entire list should the ID never be found.
	var _struct	= noone;
	var _first	= 0;
	var _second = _length - 1;
	while(_first <= _second){
		_struct = global.structs[| _first];
		if (_struct.id == _id) // First index's struct has the matching ID; return its value.
			return _first;
		
		// Exits out of the loop prematurely to avoid a second check on the same struct (This occurs whenever
		// the signs of the two index values match at the end of the binary search) if the ID didn't match.
		if (_first == _second)
			break;
			
		_struct = global.structs[| _second];
		if (_struct.id == _id) // Second index's struct has the matching ID; return its value. 
			return _second;
		
		// Increment the first index and decrement the second index value. The loop exits when these values
		// are equal (Occurs whenever both values are even or odd) or the first value has exceeded the value
		// of the second index (Occurs whenever one value is even and the other is odd).
		_first++;
		_second--;
	}
	
	// The struct with the matching ID value couldn't be found; return the default failure value.
	return -1;
}